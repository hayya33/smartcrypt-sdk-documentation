{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Getting started \u00b6 The SDK is made up of several components to address different use cases. File encryption \u00b6 The file encryption component protects files by creating encrypted ZIP files. Key management \u00b6 The key management component facilitates retrieving, modifying, and issueing Smartkeys.","title":"Overview"},{"location":"#getting-started","text":"The SDK is made up of several components to address different use cases.","title":"Getting started"},{"location":"#file-encryption","text":"The file encryption component protects files by creating encrypted ZIP files.","title":"File encryption"},{"location":"#key-management","text":"The key management component facilitates retrieving, modifying, and issueing Smartkeys.","title":"Key management"},{"location":"changelog/","text":"Change Log \u00b6 Version 2019.7.1 \u00b6 2019-07-01 Add MetaClient#loginImplicitAccount() for logging into SMDS using a system account. Remove OkHttpNetworkRequestProcessor and the OkHttp dependency. Add AccountManagement#loginImplicitAccount() for logging into SMDS using a system account. Version 2019.3.1 \u00b6 2019-03-01 Bug fixes Version 2019.2.1 \u00b6 2019-01-31 Bug fixes Version 2018.12.1 \u00b6 2019-01-02 Format preserving encryption range checking Build and test improvements Version 2018.11.1 \u00b6 2018-11-30 SmartkeyFeature and it\u2019s implementation has been removed. Instead, use com.pkware.smartcrypt.metaclient.Feature . Previously, to identify the type of feature, an instanceof check was used. Now, compare the value of Feature#getName() against constants in the Feature class. Version 2018.10.1 \u00b6 2018-11-01 Bug fixes Version 2018.9.3 \u00b6 2018-10-22 Fix segfault that occurred on some Oracle Linux systems Version 2018.9.2 \u00b6 2018-10-12 Reduce system requirements in native code on Linux Version 2018.9.1 \u00b6 2018-09-24 Bug fixes Version 2018.8.1 \u00b6 2018-08-23 Javadocs now link against external documentation Version 2018.7.2 \u00b6 2018-08-17 Fix issue when using MetaClientPasswordListener with Smartkeys that have multiple Asset Keys Version 2018.7.1 \u00b6 2018-07-25 New Unstructured Data API Minor changes to the MetaClient API Javadocs and source as part of Maven artifact Version 2018.6.2 \u00b6 2018-07-02 Fix POM Version 2018.6.1 \u00b6 2018-06-29 Initial release","title":"Change log"},{"location":"changelog/#change-log","text":"","title":"Change Log"},{"location":"changelog/#version-201971","text":"2019-07-01 Add MetaClient#loginImplicitAccount() for logging into SMDS using a system account. Remove OkHttpNetworkRequestProcessor and the OkHttp dependency. Add AccountManagement#loginImplicitAccount() for logging into SMDS using a system account.","title":"Version 2019.7.1"},{"location":"changelog/#version-201931","text":"2019-03-01 Bug fixes","title":"Version 2019.3.1"},{"location":"changelog/#version-201921","text":"2019-01-31 Bug fixes","title":"Version 2019.2.1"},{"location":"changelog/#version-2018121","text":"2019-01-02 Format preserving encryption range checking Build and test improvements","title":"Version 2018.12.1"},{"location":"changelog/#version-2018111","text":"2018-11-30 SmartkeyFeature and it\u2019s implementation has been removed. Instead, use com.pkware.smartcrypt.metaclient.Feature . Previously, to identify the type of feature, an instanceof check was used. Now, compare the value of Feature#getName() against constants in the Feature class.","title":"Version 2018.11.1"},{"location":"changelog/#version-2018101","text":"2018-11-01 Bug fixes","title":"Version 2018.10.1"},{"location":"changelog/#version-201893","text":"2018-10-22 Fix segfault that occurred on some Oracle Linux systems","title":"Version 2018.9.3"},{"location":"changelog/#version-201892","text":"2018-10-12 Reduce system requirements in native code on Linux","title":"Version 2018.9.2"},{"location":"changelog/#version-201891","text":"2018-09-24 Bug fixes","title":"Version 2018.9.1"},{"location":"changelog/#version-201881","text":"2018-08-23 Javadocs now link against external documentation","title":"Version 2018.8.1"},{"location":"changelog/#version-201872","text":"2018-08-17 Fix issue when using MetaClientPasswordListener with Smartkeys that have multiple Asset Keys","title":"Version 2018.7.2"},{"location":"changelog/#version-201871","text":"2018-07-25 New Unstructured Data API Minor changes to the MetaClient API Javadocs and source as part of Maven artifact","title":"Version 2018.7.1"},{"location":"changelog/#version-201862","text":"2018-07-02 Fix POM","title":"Version 2018.6.2"},{"location":"changelog/#version-201861","text":"2018-06-29 Initial release","title":"Version 2018.6.1"},{"location":"contentLicense/","text":"Content License \u00b6 For the purposes of licensing, the content of this web site is divided into two categories: Documentation content, including both static documentation and content extracted from source code modules, as well as sample code, and All other site content Unless otherwise noted, the documentation on this site, including any code shown in it, is made available to you under the MIT license. Third-party components of this site such as JavaScript libraries are included under the licenses specified by their authors. All other content on this site, except the license documents themselves and as otherwise noted, is licensed under the Creative Commons Attribution 4.0 license. You may use the content of this site in any way that is consistent with the specific license that applies to the content, as described above. For content licensed under Creative Commons Attribution 4.0, we ask that you give proper attribution to PKWARE, Inc. Restrictions \u00b6 While the documentation itself is available to you under the MIT or other licenses noted, proprietary trademarks and brand features are not included in that license. PKWARE\u2019s trademarks and other brand features are not included in the license. Contact PKWARE for usage details. In addition, content linked from a page on this site is not covered by the license unless specifically noted. For example, pages may link to videos or external documentation that are not covered. The use of sample source code provided in the SDK or shown in this documentation is subject to the conditions detailed in the MIT license. Attribution \u00b6 Proper attribution is required when you reuse or create modified versions of content that appears on a page made available under the terms of the Creative Commons Attribution license. On this site, the requirement for attribution applies only to the non-documentation content, as described earlier in this document. In practice we ask that you provide attribution to the Android Open Source project to the best of the ability of the medium in which you are producing the work. There are several typical ways in which this might apply: Exact Reproductions \u00b6 If your online work exactly reproduces text or images from this site, in whole or in part, please include a paragraph at the bottom of your page that reads: Portions of this page are reproduced from work created and shared by PKWARE, Inc. and used according to terms described in the Creative Commons 4.0 Attribution License. Also, please link back to the original source page so that readers can refer there for more information. Modified Versions \u00b6 If your online work shows modified text or images based on the content from this site, please include a paragraph at the bottom of your page that reads: Portions of this page are modifications based on work created and shared by PKWARE, Inc. and used according to terms described in the Creative Commons 4.0 Attribution License. Again, please link back to the original source page so that readers can refer there for more information. This is even more important when the content has been modified. Other Media \u00b6 If you produce non-hypertext works, such as books, audio, or video, we ask that you make a best effort to include a spoken or written attribution in the spirit of the messages above. We thank the Android Open Source Project for the template from which this page was made.","title":"Content License"},{"location":"contentLicense/#content-license","text":"For the purposes of licensing, the content of this web site is divided into two categories: Documentation content, including both static documentation and content extracted from source code modules, as well as sample code, and All other site content Unless otherwise noted, the documentation on this site, including any code shown in it, is made available to you under the MIT license. Third-party components of this site such as JavaScript libraries are included under the licenses specified by their authors. All other content on this site, except the license documents themselves and as otherwise noted, is licensed under the Creative Commons Attribution 4.0 license. You may use the content of this site in any way that is consistent with the specific license that applies to the content, as described above. For content licensed under Creative Commons Attribution 4.0, we ask that you give proper attribution to PKWARE, Inc.","title":"Content License"},{"location":"contentLicense/#restrictions","text":"While the documentation itself is available to you under the MIT or other licenses noted, proprietary trademarks and brand features are not included in that license. PKWARE\u2019s trademarks and other brand features are not included in the license. Contact PKWARE for usage details. In addition, content linked from a page on this site is not covered by the license unless specifically noted. For example, pages may link to videos or external documentation that are not covered. The use of sample source code provided in the SDK or shown in this documentation is subject to the conditions detailed in the MIT license.","title":"Restrictions"},{"location":"contentLicense/#attribution","text":"Proper attribution is required when you reuse or create modified versions of content that appears on a page made available under the terms of the Creative Commons Attribution license. On this site, the requirement for attribution applies only to the non-documentation content, as described earlier in this document. In practice we ask that you provide attribution to the Android Open Source project to the best of the ability of the medium in which you are producing the work. There are several typical ways in which this might apply:","title":"Attribution"},{"location":"contentLicense/#exact-reproductions","text":"If your online work exactly reproduces text or images from this site, in whole or in part, please include a paragraph at the bottom of your page that reads: Portions of this page are reproduced from work created and shared by PKWARE, Inc. and used according to terms described in the Creative Commons 4.0 Attribution License. Also, please link back to the original source page so that readers can refer there for more information.","title":"Exact Reproductions"},{"location":"contentLicense/#modified-versions","text":"If your online work shows modified text or images based on the content from this site, please include a paragraph at the bottom of your page that reads: Portions of this page are modifications based on work created and shared by PKWARE, Inc. and used according to terms described in the Creative Commons 4.0 Attribution License. Again, please link back to the original source page so that readers can refer there for more information. This is even more important when the content has been modified.","title":"Modified Versions"},{"location":"contentLicense/#other-media","text":"If you produce non-hypertext works, such as books, audio, or video, we ask that you make a best effort to include a spoken or written attribution in the spirit of the messages above. We thank the Android Open Source Project for the template from which this page was made.","title":"Other Media"},{"location":"faq/","text":"FAQ \u00b6 What\u2019s a Smartkey? \u00b6 A Smartkey is a managed, 256 bit symmetric encryption key with cryptographically validated metadata. Smartkeys are stored in the Smartcrypt Enterprise Manager for easy auditing and escrow. Smartkeys have access control lists built-in and can be versioned, allowing for key rotation. Smartkey Kinds and Owners \u00b6 Smartkey kinds are used to sort Smartkeys into logical groups. For example, you might have multiple keys used for encrypting personally identifiable information (PII), multiple keys for encrypting file shares, and multiple keys that only certain Active Directory groups should ever have access to. By creating a Kind for each of these scenarios, you can group the keys and define internal policies for how keys should be distributed to Applications. Each Smartkey is owned by an identity. Most identities map to a user in Active Directory, but the PKWARE Enterprise Manager also has an identity. Only the owner of a Smartkey is able to manage it, performing actions like modifying who has access and changing it\u2019s name. I\u2019m familiar with using RSA keys; what\u2019s the Smartcrypt equivalent? \u00b6 Smartcrypt does not have a cryptographic primitive equivalent to RSA keys. Instead, Smartcrypt uses cryptographically validated\u200b metadata to perform the most common task for which asymmetric encryption is used: managing access to the symmetric key. Smartkeys are distributed to authorized users automatically. When a user\u2019s access to a Smartkey is removed, the Smartkey is automatically deleted from their systems. Additionally, rotatable Smartkeys are rotated, so a new key is issued to all users still authorized to use the Smartkey, and all new encryptions are performed with the new key. What\u2019s the difference between rotatable and non-rotatable Smartkeys? \u00b6 Smartkeys are versioned symmetric keys. When a Smartkey is rotated, a new key is issued and is attached to the Smartkey as a version. Rotation typically happens when users are removed from the access control list for the Smartkey, but can also be initiated for other reasons. Most Smartkeys are, and most scenarios want to use, rotatable Smartkeys. There are certain scenarios, such as Format and Length Preserving Encryption, where key rotation is not acceptable. For such scenarios, non-rotatable Smartkeys exist. Skipping key rotation weakens the long-term security of a Smartkey, so be sure to read the FLPE docs before proceeding. Why are my Smartkeys not syncing to my client? \u00b6 It\u2019s possible that the Application you are using does not have a mapping for the Smartkey Kind . See the PKWARE Enterprise Manager Documentation for configuration details.","title":"FAQ"},{"location":"faq/#faq","text":"","title":"FAQ"},{"location":"faq/#whats-a-smartkey","text":"A Smartkey is a managed, 256 bit symmetric encryption key with cryptographically validated metadata. Smartkeys are stored in the Smartcrypt Enterprise Manager for easy auditing and escrow. Smartkeys have access control lists built-in and can be versioned, allowing for key rotation.","title":"What's a Smartkey?"},{"location":"faq/#smartkey-kinds-and-owners","text":"Smartkey kinds are used to sort Smartkeys into logical groups. For example, you might have multiple keys used for encrypting personally identifiable information (PII), multiple keys for encrypting file shares, and multiple keys that only certain Active Directory groups should ever have access to. By creating a Kind for each of these scenarios, you can group the keys and define internal policies for how keys should be distributed to Applications. Each Smartkey is owned by an identity. Most identities map to a user in Active Directory, but the PKWARE Enterprise Manager also has an identity. Only the owner of a Smartkey is able to manage it, performing actions like modifying who has access and changing it\u2019s name.","title":"Smartkey Kinds and Owners"},{"location":"faq/#im-familiar-with-using-rsa-keys-whats-the-smartcrypt-equivalent","text":"Smartcrypt does not have a cryptographic primitive equivalent to RSA keys. Instead, Smartcrypt uses cryptographically validated\u200b metadata to perform the most common task for which asymmetric encryption is used: managing access to the symmetric key. Smartkeys are distributed to authorized users automatically. When a user\u2019s access to a Smartkey is removed, the Smartkey is automatically deleted from their systems. Additionally, rotatable Smartkeys are rotated, so a new key is issued to all users still authorized to use the Smartkey, and all new encryptions are performed with the new key.","title":"I'm familiar with using RSA keys; what's the Smartcrypt equivalent?"},{"location":"faq/#whats-the-difference-between-rotatable-and-non-rotatable-smartkeys","text":"Smartkeys are versioned symmetric keys. When a Smartkey is rotated, a new key is issued and is attached to the Smartkey as a version. Rotation typically happens when users are removed from the access control list for the Smartkey, but can also be initiated for other reasons. Most Smartkeys are, and most scenarios want to use, rotatable Smartkeys. There are certain scenarios, such as Format and Length Preserving Encryption, where key rotation is not acceptable. For such scenarios, non-rotatable Smartkeys exist. Skipping key rotation weakens the long-term security of a Smartkey, so be sure to read the FLPE docs before proceeding.","title":"What's the difference between rotatable and non-rotatable Smartkeys?"},{"location":"faq/#why-are-my-smartkeys-not-syncing-to-my-client","text":"It\u2019s possible that the Application you are using does not have a mapping for the Smartkey Kind . See the PKWARE Enterprise Manager Documentation for configuration details.","title":"Why are my Smartkeys not syncing to my client?"},{"location":"structured/","text":"// TODO \u00b6","title":"// TODO"},{"location":"structured/#todo","text":"","title":"// TODO"},{"location":"troubleshooting/","text":"Troubleshooting \u00b6 Self-signed SSL certificate \u00b6 When using a self-signed SSL certificate on your Smartcrypt Enterprise Manager, you\u2019ll likely encounter an error like those below. Self-signed SSL certificates are not supported. com . pkware . smartcrypt . metaclient . MetaClientException : sun . security . validator . ValidatorException : PKIX path building failed : sun . security . provider . certpath . SunCertPathBuilderException : unable to find valid certification path to requested target Details: GET https : //demoserver.smartcrypt.com/mds/api/v1.0/clusterInfo 0 at com . pkware . smartcrypt . metaclient . NativeMetaClient . loginManagedAccount ( Native Method ) at com . pkware . smartcrypt . keymanagement . MetaClientAccountManagement . loginManagedAccount ( MetaClientAccountManagement . java : 26 ) Unable to connect to server \u00b6 If unable to connect to the server, you will encounter error messages with varying degrees of clarity. The SDK relies on the underlying platform (runtime & OS) to resolve the server and generate error messages. The following are error you might encounter. com . pkware . smartcrypt . metaclient . MetaClientException : demoserver . smartcrypt . com : nodename nor servname provided , or not known Details: GET https : //demoserver.smartcrypt.com/mds/api/v1.0/clusterInfo 0 at com . pkware . smartcrypt . metaclient . NativeMetaClient . loginManagedAccount ( Native Method ) at com . pkware . smartcrypt . keymanagement . MetaClientAccountManagement . loginManagedAccount ( MetaClientAccountManagement . java : 26 ) To start troubleshooting, try to contact the server from code without the SDK. The following snippets demonstrate how to do this. Be sure to replace the URL in the snippets with that of your server. Java import org.apache.http.client.methods.CloseableHttpResponse ; import org.apache.http.client.methods.HttpUriRequest ; import org.apache.http.client.methods.RequestBuilder ; import org.apache.http.impl.client.CloseableHttpClient ; import org.apache.http.impl.client.HttpClients ; import java.io.IOException ; public class Program { public static void main ( String [] args ) throws IOException { try ( CloseableHttpClient client = HttpClients . createDefault ()) { HttpUriRequest request = RequestBuilder . get ( \"https://demoserver.smartcrypt.com/mds/api/v1.0/clusterInfo\" ) . build (); try ( CloseableHttpResponse response = client . execute ( request )) { System . out . println ( response . getStatusLine ()); } } } } Kotlin import org.apache.http.client.methods.RequestBuilder import org.apache.http.impl.client.HttpClients import java.io.IOException @Throws ( IOException :: class ) fun main () { HttpClients . createDefault (). use { client -> val request = RequestBuilder . get ( \"https://demoserver.smartcrypt.com/mds/api/v1.0/clusterInfo\" ) . build () client . execute ( request ). use { response -> println ( response . statusLine ) } } }","title":"Troubleshooting"},{"location":"troubleshooting/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"troubleshooting/#self-signed-ssl-certificate","text":"When using a self-signed SSL certificate on your Smartcrypt Enterprise Manager, you\u2019ll likely encounter an error like those below. Self-signed SSL certificates are not supported. com . pkware . smartcrypt . metaclient . MetaClientException : sun . security . validator . ValidatorException : PKIX path building failed : sun . security . provider . certpath . SunCertPathBuilderException : unable to find valid certification path to requested target Details: GET https : //demoserver.smartcrypt.com/mds/api/v1.0/clusterInfo 0 at com . pkware . smartcrypt . metaclient . NativeMetaClient . loginManagedAccount ( Native Method ) at com . pkware . smartcrypt . keymanagement . MetaClientAccountManagement . loginManagedAccount ( MetaClientAccountManagement . java : 26 )","title":"Self-signed SSL certificate"},{"location":"troubleshooting/#unable-to-connect-to-server","text":"If unable to connect to the server, you will encounter error messages with varying degrees of clarity. The SDK relies on the underlying platform (runtime & OS) to resolve the server and generate error messages. The following are error you might encounter. com . pkware . smartcrypt . metaclient . MetaClientException : demoserver . smartcrypt . com : nodename nor servname provided , or not known Details: GET https : //demoserver.smartcrypt.com/mds/api/v1.0/clusterInfo 0 at com . pkware . smartcrypt . metaclient . NativeMetaClient . loginManagedAccount ( Native Method ) at com . pkware . smartcrypt . keymanagement . MetaClientAccountManagement . loginManagedAccount ( MetaClientAccountManagement . java : 26 ) To start troubleshooting, try to contact the server from code without the SDK. The following snippets demonstrate how to do this. Be sure to replace the URL in the snippets with that of your server. Java import org.apache.http.client.methods.CloseableHttpResponse ; import org.apache.http.client.methods.HttpUriRequest ; import org.apache.http.client.methods.RequestBuilder ; import org.apache.http.impl.client.CloseableHttpClient ; import org.apache.http.impl.client.HttpClients ; import java.io.IOException ; public class Program { public static void main ( String [] args ) throws IOException { try ( CloseableHttpClient client = HttpClients . createDefault ()) { HttpUriRequest request = RequestBuilder . get ( \"https://demoserver.smartcrypt.com/mds/api/v1.0/clusterInfo\" ) . build (); try ( CloseableHttpResponse response = client . execute ( request )) { System . out . println ( response . getStatusLine ()); } } } } Kotlin import org.apache.http.client.methods.RequestBuilder import org.apache.http.impl.client.HttpClients import java.io.IOException @Throws ( IOException :: class ) fun main () { HttpClients . createDefault (). use { client -> val request = RequestBuilder . get ( \"https://demoserver.smartcrypt.com/mds/api/v1.0/clusterInfo\" ) . build () client . execute ( request ). use { response -> println ( response . statusLine ) } } }","title":"Unable to connect to server"},{"location":"concepts/flpe/","text":"Format and Length Preserving Encryption \u00b6 Format and Length Preserving Encryption (FLPE) are ways of encrypting data while keeping the cipher text format or size the same as the input. For example, with format preserving encryption, a credit card number will still look like a credit card number after encrypting, and will still pass the Luhn check required. With length preserving encryption, the cipher text will have the same size as the plain text. These approaches comes with security implications that must be understood. On key rotation \u00b6 FLPE requires that the output be the same format or length as the input, which means that no information about the key can be stored with the cipher text. Additionally, the premise for FLPE is that the storage container cannot be changed, so key information cannot be stored alongside the cipher text. This means that once a key is selected for encryption, that same key needs to be used for all data. For the SDK, that means using a non-rotatable Smartkey. Non-rotatable Smartkeys have serious drawbacks. When a user with access to a non-rotatable Smartkey has their access revoked, Smartcrypt deletes the key from the user\u2019s devices, same as with rotatable Smartkeys. However, the key could have been compromised. With rotatable Smartkeys we issue a new encryption key for use in all future encryptions, thereby ensuring that the removed user cannot access new data; with non-rotatable Smartkeys we continue to use the same encryption key.","title":"Format and length preserving encryption"},{"location":"concepts/flpe/#format-and-length-preserving-encryption","text":"Format and Length Preserving Encryption (FLPE) are ways of encrypting data while keeping the cipher text format or size the same as the input. For example, with format preserving encryption, a credit card number will still look like a credit card number after encrypting, and will still pass the Luhn check required. With length preserving encryption, the cipher text will have the same size as the plain text. These approaches comes with security implications that must be understood.","title":"Format and Length Preserving Encryption"},{"location":"concepts/flpe/#on-key-rotation","text":"FLPE requires that the output be the same format or length as the input, which means that no information about the key can be stored with the cipher text. Additionally, the premise for FLPE is that the storage container cannot be changed, so key information cannot be stored alongside the cipher text. This means that once a key is selected for encryption, that same key needs to be used for all data. For the SDK, that means using a non-rotatable Smartkey. Non-rotatable Smartkeys have serious drawbacks. When a user with access to a non-rotatable Smartkey has their access revoked, Smartcrypt deletes the key from the user\u2019s devices, same as with rotatable Smartkeys. However, the key could have been compromised. With rotatable Smartkeys we issue a new encryption key for use in all future encryptions, thereby ensuring that the removed user cannot access new data; with non-rotatable Smartkeys we continue to use the same encryption key.","title":"On key rotation"},{"location":"concepts/logging/","text":"Logging \u00b6 By default, all log statements will be printed to the console. This works fine for development, but is not recommended for production. Instead, it is recommended that you provide a logging target that suits your application\u2019s production environment. Configuring Logging \u00b6 To customize logging, subclass the Logger class and provide an instance of your class to the MetaClient Builder . The most common behavior toggle is to change the logging level. Use the setter to set the level you desire. You can also control the format of the tag . The tag is useful for differentiating multiple threads or instances. You can customize the tag by overriding the formatTag method. Common Strategies \u00b6 Enable trace logging \u00b6 Trace logging is particularly useful when trying to debug connection issues and when contacting PKWARE support. Java import com.pkware.smartcrypt.metaclient.Logger ; import com.pkware.smartcrypt.metaclient.MetaClient ; import com.pkware.smartcrypt.metaclient.NativeMetaClient ; // Use the ConsoleLogger from the SDK, or a custom implementation you write Logger logger = new ConsoleLogger (); // Set the custom log level logger . setLevel ( Logger . Level . TRACE ); MetaClient metaClient = new NativeMetaClient . Builder () . logger ( logger ) // Set other properties . build (); Kotlin import com.pkware.smartcrypt.metaclient.Logger import com.pkware.smartcrypt.metaclient.MetaClient import com.pkware.smartcrypt.metaclient.NativeMetaClient // Use the ConsoleLogger from the SDK, or a custom implementation you write val logger = ConsoleLogger () // Set the custom log level logger . level = Logger . Level . TRACE val metaClient = NativeMetaClient . Builder () . logger ( logger ) // Set other properties . build () Disable logging \u00b6 There is no toggle to disable logging. Instead, set the level to ERROR and provide an empty implementation of the log method. Change logging destinations after initialization \u00b6 You may want to change where messages are logged during the execution of your program. To do this, customize your Logger subclass to maintain the information of where, when, and how to log. This gives you full control over the structure, threading, and lifecycles of your application logging.","title":"Logging"},{"location":"concepts/logging/#logging","text":"By default, all log statements will be printed to the console. This works fine for development, but is not recommended for production. Instead, it is recommended that you provide a logging target that suits your application\u2019s production environment.","title":"Logging"},{"location":"concepts/logging/#configuring-logging","text":"To customize logging, subclass the Logger class and provide an instance of your class to the MetaClient Builder . The most common behavior toggle is to change the logging level. Use the setter to set the level you desire. You can also control the format of the tag . The tag is useful for differentiating multiple threads or instances. You can customize the tag by overriding the formatTag method.","title":"Configuring Logging"},{"location":"concepts/logging/#common-strategies","text":"","title":"Common Strategies"},{"location":"concepts/logging/#enable-trace-logging","text":"Trace logging is particularly useful when trying to debug connection issues and when contacting PKWARE support. Java import com.pkware.smartcrypt.metaclient.Logger ; import com.pkware.smartcrypt.metaclient.MetaClient ; import com.pkware.smartcrypt.metaclient.NativeMetaClient ; // Use the ConsoleLogger from the SDK, or a custom implementation you write Logger logger = new ConsoleLogger (); // Set the custom log level logger . setLevel ( Logger . Level . TRACE ); MetaClient metaClient = new NativeMetaClient . Builder () . logger ( logger ) // Set other properties . build (); Kotlin import com.pkware.smartcrypt.metaclient.Logger import com.pkware.smartcrypt.metaclient.MetaClient import com.pkware.smartcrypt.metaclient.NativeMetaClient // Use the ConsoleLogger from the SDK, or a custom implementation you write val logger = ConsoleLogger () // Set the custom log level logger . level = Logger . Level . TRACE val metaClient = NativeMetaClient . Builder () . logger ( logger ) // Set other properties . build ()","title":"Enable trace logging"},{"location":"concepts/logging/#disable-logging","text":"There is no toggle to disable logging. Instead, set the level to ERROR and provide an empty implementation of the log method.","title":"Disable logging"},{"location":"concepts/logging/#change-logging-destinations-after-initialization","text":"You may want to change where messages are logged during the execution of your program. To do this, customize your Logger subclass to maintain the information of where, when, and how to log. This gives you full control over the structure, threading, and lifecycles of your application logging.","title":"Change logging destinations after initialization"},{"location":"concepts/notifications/","text":"Notifications \u00b6 Notifications are the mechanism used by the Smartcrypt SDK to provide insight to events that have happened in the background. Often they are useful to a user, but sometimes developers simply want to log certain events. This document describes the notifications available and how to use them. Responding to Notifications \u00b6 Some Notifications require a response. For example, when another user requests access to a Smartkey, a response should be provided to indicate whether or not access should be granted. Notifications can be responded to using DataStorage#respondToNotification() . Technical details \u00b6 For technical information about the types of Notifications and their priorities, see subclasses of Notification and NotificationPriority .","title":"Notifications"},{"location":"concepts/notifications/#notifications","text":"Notifications are the mechanism used by the Smartcrypt SDK to provide insight to events that have happened in the background. Often they are useful to a user, but sometimes developers simply want to log certain events. This document describes the notifications available and how to use them.","title":"Notifications"},{"location":"concepts/notifications/#responding-to-notifications","text":"Some Notifications require a response. For example, when another user requests access to a Smartkey, a response should be provided to indicate whether or not access should be granted. Notifications can be responded to using DataStorage#respondToNotification() .","title":"Responding to Notifications"},{"location":"concepts/notifications/#technical-details","text":"For technical information about the types of Notifications and their priorities, see subclasses of Notification and NotificationPriority .","title":"Technical details"},{"location":"concepts/observables/","text":"Observables \u00b6 The Smartcrypt Key Management component relies heavily on Observables. These may be unfamiliar, but are easy to get a hang of or convert to a more familiar paradigm. If unfamiliar with reactive programming, we recommend taking a look at the ReactiveX website for tutorials, guides, and more. Java import io.reactivex.Observable ; // Observables emit a stream of events. This is a push model rather than a pull model. Observable < Integer > observable = Observable . range ( 0 , 5 ); // Observables can be transformed Observable < String > intsAsStrings = observable . map ( Object :: toString ); // Use common stream/observable operators Observable < String > filteredInts = intsAsStrings . filter ( number -> ! \"3\" . equals ( number )); // Observables only process when subscribed to. All of the previous \"work\" is only setup - none of it has // run yet. When we subscribe now, the work will happen. Disposable subscription = filteredInts . subscribe ( System . out :: println ); // Subscriptions must be disposed when we're done with them, otherwise the stream will continue processing // when we no longer need it subscription . dispose (); /* * Observables can also be made blocking, effectively making them a single, synchronous call */ Integer lastNumberBlocking = Observable . range ( 0 , 4 ). blockingLast (); System . out . println ( \"With a blocking call: \" + lastNumberBlocking ); Kotlin import io.reactivex.Observable // Observables emit a stream of events. This is a push model rather than a pull model. val observable = Observable . range ( 0 , 5 ) // Observables can be transformed val intsAsStrings = observable . map ( Int :: toString ) // Use common stream/observable operators val filteredInts = intsAsStrings . filter { \"3\" != it } // Observables only process when subscribed to. All of the previous \"work\" is only setup - none of it has // run yet. When we subscribe now, the work will happen. val subscription = filteredInts . subscribe ( :: println ) // Subscriptions must be disposed when we're done with them, otherwise the stream will continue processing // when we no longer need it subscription . dispose () /* * Observables can also be made blocking, effectively making them a single, synchronous call */ val lastNumberBlocking = Observable . range ( 0 , 4 ). blockingLast () println ( \"With a blocking call: $lastNumberBlocking\" )","title":"Observables"},{"location":"concepts/observables/#observables","text":"The Smartcrypt Key Management component relies heavily on Observables. These may be unfamiliar, but are easy to get a hang of or convert to a more familiar paradigm. If unfamiliar with reactive programming, we recommend taking a look at the ReactiveX website for tutorials, guides, and more. Java import io.reactivex.Observable ; // Observables emit a stream of events. This is a push model rather than a pull model. Observable < Integer > observable = Observable . range ( 0 , 5 ); // Observables can be transformed Observable < String > intsAsStrings = observable . map ( Object :: toString ); // Use common stream/observable operators Observable < String > filteredInts = intsAsStrings . filter ( number -> ! \"3\" . equals ( number )); // Observables only process when subscribed to. All of the previous \"work\" is only setup - none of it has // run yet. When we subscribe now, the work will happen. Disposable subscription = filteredInts . subscribe ( System . out :: println ); // Subscriptions must be disposed when we're done with them, otherwise the stream will continue processing // when we no longer need it subscription . dispose (); /* * Observables can also be made blocking, effectively making them a single, synchronous call */ Integer lastNumberBlocking = Observable . range ( 0 , 4 ). blockingLast (); System . out . println ( \"With a blocking call: \" + lastNumberBlocking ); Kotlin import io.reactivex.Observable // Observables emit a stream of events. This is a push model rather than a pull model. val observable = Observable . range ( 0 , 5 ) // Observables can be transformed val intsAsStrings = observable . map ( Int :: toString ) // Use common stream/observable operators val filteredInts = intsAsStrings . filter { \"3\" != it } // Observables only process when subscribed to. All of the previous \"work\" is only setup - none of it has // run yet. When we subscribe now, the work will happen. val subscription = filteredInts . subscribe ( :: println ) // Subscriptions must be disposed when we're done with them, otherwise the stream will continue processing // when we no longer need it subscription . dispose () /* * Observables can also be made blocking, effectively making them a single, synchronous call */ val lastNumberBlocking = Observable . range ( 0 , 4 ). blockingLast () println ( \"With a blocking call: $lastNumberBlocking\" )","title":"Observables"},{"location":"fileEncryption/","text":"File encryption \u00b6 The file encryption component uses ZIP files to protect sensitive data. ZIP files are an ideal format, as a lot of software are aware of the format and work well with it. ZIPs also come with a range of desireable properties: Easy-to-use compression of data prior to encryption . Support for encrypting an entire folder hierarchy, thereby keeping related files together and allowing them to be easily shared. File name encryption, thereby protecting potentially sensitive document file names. Embedded support for Smartkeys, including Community keys and Contingency Groups. Setup \u00b6 To get started, you\u2019ll need to create a new instance of UnstructuredData . See the MetaClient docs for details on how to obtain the MetaClient instance. Java import com.pkware.smartcrypt.metaclient.MetaClient ; import com.pkware.smartcrypt.unstructured.UnstructuredData ; import com.pkware.smartcrypt.unstructured.UnstructuredDataImpl ; public static UnstructuredData setUp ( MetaClient metaClient ) { return new UnstructuredDataImpl . Builder () . metaClient ( metaClient ) . license ( \"<Your license here>\" ) . build (); } Kotlin import com.pkware.smartcrypt.metaclient.MetaClient import com.pkware.smartcrypt.unstructured.UnstructuredData import com.pkware.smartcrypt.unstructured.UnstructuredDataImpl fun setUp ( metaClient : MetaClient ): UnstructuredData = UnstructuredDataImpl . Builder () . metaClient ( metaClient ) . license ( \"<Your license here>\" ) . build () Instances of UnstructuredData are thread safe and should be reused throughout your application. Create a ZIP \u00b6 The basic steps of creating a ZIP are the same regardless of which encryption parameters are used. Java import com.pkware.archive.zip.ZipArchiveEntry ; import com.pkware.archive.zip.ZipArchiveOutputFile ; import com.pkware.smartcrypt.unstructured.UnstructuredData ; import java.io.IOException ; import java.io.InputStream ; import java.util.Map ; public static void createZip ( UnstructuredData unstructured , Map < String , InputStream > filesToArchive ) throws IOException { // A stream variant is also available try ( ZipArchiveOutputFile zip = unstructured . newZipOutputFile ( \"test.zip\" )) { for ( Map . Entry < String , InputStream > dataToArchive : filesToArchive . entrySet ()) { String entryName = dataToArchive . getKey (); InputStream entryContent = dataToArchive . getValue (); ZipArchiveEntry zipEntry = zip . createArchiveEntry ( null , entryName ); zip . addEntry ( zipEntry , entryContent ); } } } Kotlin import com.pkware.smartcrypt.unstructured.UnstructuredData import java.io.IOException import java.io.InputStream @Throws ( IOException :: class ) fun createZip ( unstructured : UnstructuredData , filesToArchive : Map < String , InputStream > ) { // A stream variant is also available unstructured . newZipOutputFile ( \"test.zip\" ). use { zip -> for (( entryName , entryContent ) in filesToArchive ) { val zipEntry = zip . createArchiveEntry ( null , entryName ) zip . addEntry ( zipEntry , entryContent ) } } } Configuring encryption \u00b6 By default, the SDK chooses an encryption method that provides strong security and is well suited for most applications. It may be desirable to change the encryption method (also called the encryption algorithm) used to create new ZIP entries. The SDK provides a simple of way setting the most common and useful encryption methods. Java import com.pkware.archive.ArchiveEntry ; import com.pkware.archive.zip.ZipArchiveOutput ; public static void configureEncryptionMethod ( ZipArchiveOutput zip ) { // Configure encryption to use AE2 (for compatibility with other ZIP programs) zip . setCryptAlgorithm ( ArchiveEntry . CRYPT_AE2 ); // Configure encryption to use AES-256 zip . setCryptAlgorithm ( ArchiveEntry . CRYPT_AES_256 ); } Kotlin import com.pkware.archive.ArchiveEntry import com.pkware.archive.zip.ZipArchiveOutput fun configureEncryptionMethod ( zip : ZipArchiveOutput ) { // Configure encryption to use AE2 (for compatibility with other ZIP programs) zip . cryptAlgorithm = ArchiveEntry . CRYPT_AE2 . toInt () // Configure encryption to use AES-256 zip . cryptAlgorithm = ArchiveEntry . CRYPT_AES_256 . toInt () } Configuring compression \u00b6 By default, the SDK chooses compression setting that balances speed with compressed size. However, it is possible to change the compression method. One might use a different compression algorithm , such as deflate, store, and LZMA, or specify a different compression level (higher for smaller ZIPs, lower for faster processing) as the application requires. Java import com.pkware.archive.ArchiveEntry ; import com.pkware.archive.zip.ZipArchiveOutput ; public static void compressionMethod ( ZipArchiveOutput zip ) { // Configure compression to use the deflate algorithm at level 6 zip . setCompressMethod ( ArchiveEntry . COMPRESS_METHOD_DEFLATE , 6 ); // Configure compression to use the store algorithm (no compression) zip . setCompressMethod ( ArchiveEntry . COMPRESS_METHOD_STORE ); } Kotlin import com.pkware.archive.ArchiveEntry import com.pkware.archive.zip.ZipArchiveOutput fun compressionMethod ( zip : ZipArchiveOutput ) { // Configure compression to use the deflate algorithm at level 6 zip . setCompressMethod ( ArchiveEntry . COMPRESS_METHOD_DEFLATE , 6 ) // Configure compression to use the store algorithm (no compression) zip . compressMethod = ArchiveEntry . COMPRESS_METHOD_STORE } Encryption \u00b6 Encryption using both passwords and Smartkeys is straightforward. See the Key Management docs for details on how to obtain a Smartkey. Java import com.pkware.archive.zip.ZipArchiveOutput ; import com.pkware.smartcrypt.keymanagement.smartkeys.Smartkey ; import com.pkware.smartcrypt.metaclient.MetaClientException ; import com.pkware.smartcrypt.unstructured.EncryptionSpec ; import com.pkware.smartcrypt.unstructured.UnstructuredData ; public static void contingencyGroupWithSmartkey ( UnstructuredData unstructured , Smartkey smartkey , // Create the ZIP as you normally would ZipArchiveOutput zip ) throws MetaClientException { EncryptionSpec spec = new EncryptionSpec (); // Optionally add a password here as well spec . smartkey = smartkey ; unstructured . encrypt ( zip , spec ); // Proceed to add files to the ZIP as you normally would } Kotlin import com.pkware.archive.zip.ZipArchiveOutput import com.pkware.smartcrypt.keymanagement.smartkeys.Smartkey import com.pkware.smartcrypt.metaclient.MetaClientException import com.pkware.smartcrypt.unstructured.EncryptionSpec import com.pkware.smartcrypt.unstructured.UnstructuredData @Throws ( MetaClientException :: class ) fun contingencyGroupWithSmartkey ( unstructured : UnstructuredData , smartkey : Smartkey , // Create the ZIP as you normally would zip : ZipArchiveOutput ) { val spec = EncryptionSpec () // Optionally add a password here as well spec . smartkey = smartkey ; unstructured . encrypt ( zip , spec ) // Proceed to add files to the ZIP as you normally would } Important In order for Smartcrypt Contingency Groups to apply, you must run your application as Smartcrypt. Contingency group without Smartkey \u00b6 The recommended way to gain access to the Contingency Group functionality of Smartcrypt is to use Smartkeys when encrypting. However, there may be some scenarios in which using a Smartkey is not an option. For these scenarios, we also provide the option of skipping the Smartkey, but still gaining the benefits of Contingency Groups. Java import com.pkware.archive.zip.ZipArchiveOutput ; import com.pkware.smartcrypt.metaclient.MetaClientException ; import com.pkware.smartcrypt.unstructured.EncryptionSpec ; import com.pkware.smartcrypt.unstructured.UnstructuredData ; public static void contingencyGroupWithoutSmartkey ( UnstructuredData unstructured , // Create the ZIP as you normally would ZipArchiveOutput zip ) throws MetaClientException { EncryptionSpec spec = new EncryptionSpec (); // The password must be provided if not specifying a Smartkey to gain contingency benefits spec . password = \"secret secret\" ; unstructured . encrypt ( zip , spec ); // Proceed to add files to the ZIP as you normally would } Kotlin import com.pkware.archive.zip.ZipArchiveOutput import com.pkware.smartcrypt.metaclient.MetaClientException import com.pkware.smartcrypt.unstructured.EncryptionSpec import com.pkware.smartcrypt.unstructured.UnstructuredData @Throws ( MetaClientException :: class ) fun contingencyGroupWithoutSmartkey ( unstructured : UnstructuredData , // Create the ZIP as you normally would zip : ZipArchiveOutput ) { val spec = EncryptionSpec () // The password must be provided if not specifying a Smartkey to gain contingency benefits spec . password = \"secret secret\" ; unstructured . encrypt ( zip , spec ) // Proceed to add files to the ZIP as you normally would } Important In order for Smartcrypt Contingency Groups to apply, you must run your application as Smartcrypt. See the [MetaClient Policy] docs for more details. Decryption \u00b6 Once you have an UnstructuredData instance, decrypting ZIP archives encrypted using a Smartkey is easy! If you do not have access to the Smartkey, but are part of the Contingency Group, this snippet will also grant you access to the files. Java import com.pkware.archive.zip.ZipArchiveEntry ; import com.pkware.archive.zip.ZipFile ; import com.pkware.smartcrypt.unstructured.UnstructuredData ; import java.io.File ; import java.io.FileOutputStream ; import java.io.IOException ; import java.io.InputStream ; import java.io.OutputStream ; public static void decrypt ( UnstructuredData unstructuredData ) throws IOException { try ( ZipFile encrypted = unstructuredData . newZipFile ( new File ( \"encrypted.zip\" ))) { ZipArchiveEntry entry = encrypted . getEntry ( \"example.txt\" ); try ( OutputStream fileStream = new FileOutputStream ( \"example.txt\" )) { try ( InputStream decryptStream = encrypted . getInputStream ( entry )) { decryptStream . transferTo ( fileStream ); } } } } Kotlin import com.pkware.archive.zip.ZipArchiveEntry import com.pkware.archive.zip.ZipFile import com.pkware.smartcrypt.unstructured.UnstructuredData import java.io.File import java.io.FileOutputStream import java.io.IOException import java.io.InputStream import java.io.OutputStream @Throws ( IOException :: class ) fun decrypt ( unstructuredData : UnstructuredData ) { unstructuredData . newZipFile ( File ( \"encrypted.zip\" )). use { encrypted -> val entry = encrypted . getEntry ( \"example.txt\" ) FileOutputStream ( \"example.txt\" ). use { fileStream -> encrypted . getInputStream ( entry ). use { decryptStream -> decryptStream . transferTo ( fileStream ); } } } }","title":"Overview"},{"location":"fileEncryption/#file-encryption","text":"The file encryption component uses ZIP files to protect sensitive data. ZIP files are an ideal format, as a lot of software are aware of the format and work well with it. ZIPs also come with a range of desireable properties: Easy-to-use compression of data prior to encryption . Support for encrypting an entire folder hierarchy, thereby keeping related files together and allowing them to be easily shared. File name encryption, thereby protecting potentially sensitive document file names. Embedded support for Smartkeys, including Community keys and Contingency Groups.","title":"File encryption"},{"location":"fileEncryption/#setup","text":"To get started, you\u2019ll need to create a new instance of UnstructuredData . See the MetaClient docs for details on how to obtain the MetaClient instance. Java import com.pkware.smartcrypt.metaclient.MetaClient ; import com.pkware.smartcrypt.unstructured.UnstructuredData ; import com.pkware.smartcrypt.unstructured.UnstructuredDataImpl ; public static UnstructuredData setUp ( MetaClient metaClient ) { return new UnstructuredDataImpl . Builder () . metaClient ( metaClient ) . license ( \"<Your license here>\" ) . build (); } Kotlin import com.pkware.smartcrypt.metaclient.MetaClient import com.pkware.smartcrypt.unstructured.UnstructuredData import com.pkware.smartcrypt.unstructured.UnstructuredDataImpl fun setUp ( metaClient : MetaClient ): UnstructuredData = UnstructuredDataImpl . Builder () . metaClient ( metaClient ) . license ( \"<Your license here>\" ) . build () Instances of UnstructuredData are thread safe and should be reused throughout your application.","title":"Setup"},{"location":"fileEncryption/#create-a-zip","text":"The basic steps of creating a ZIP are the same regardless of which encryption parameters are used. Java import com.pkware.archive.zip.ZipArchiveEntry ; import com.pkware.archive.zip.ZipArchiveOutputFile ; import com.pkware.smartcrypt.unstructured.UnstructuredData ; import java.io.IOException ; import java.io.InputStream ; import java.util.Map ; public static void createZip ( UnstructuredData unstructured , Map < String , InputStream > filesToArchive ) throws IOException { // A stream variant is also available try ( ZipArchiveOutputFile zip = unstructured . newZipOutputFile ( \"test.zip\" )) { for ( Map . Entry < String , InputStream > dataToArchive : filesToArchive . entrySet ()) { String entryName = dataToArchive . getKey (); InputStream entryContent = dataToArchive . getValue (); ZipArchiveEntry zipEntry = zip . createArchiveEntry ( null , entryName ); zip . addEntry ( zipEntry , entryContent ); } } } Kotlin import com.pkware.smartcrypt.unstructured.UnstructuredData import java.io.IOException import java.io.InputStream @Throws ( IOException :: class ) fun createZip ( unstructured : UnstructuredData , filesToArchive : Map < String , InputStream > ) { // A stream variant is also available unstructured . newZipOutputFile ( \"test.zip\" ). use { zip -> for (( entryName , entryContent ) in filesToArchive ) { val zipEntry = zip . createArchiveEntry ( null , entryName ) zip . addEntry ( zipEntry , entryContent ) } } }","title":"Create a ZIP"},{"location":"fileEncryption/#configuring-encryption","text":"By default, the SDK chooses an encryption method that provides strong security and is well suited for most applications. It may be desirable to change the encryption method (also called the encryption algorithm) used to create new ZIP entries. The SDK provides a simple of way setting the most common and useful encryption methods. Java import com.pkware.archive.ArchiveEntry ; import com.pkware.archive.zip.ZipArchiveOutput ; public static void configureEncryptionMethod ( ZipArchiveOutput zip ) { // Configure encryption to use AE2 (for compatibility with other ZIP programs) zip . setCryptAlgorithm ( ArchiveEntry . CRYPT_AE2 ); // Configure encryption to use AES-256 zip . setCryptAlgorithm ( ArchiveEntry . CRYPT_AES_256 ); } Kotlin import com.pkware.archive.ArchiveEntry import com.pkware.archive.zip.ZipArchiveOutput fun configureEncryptionMethod ( zip : ZipArchiveOutput ) { // Configure encryption to use AE2 (for compatibility with other ZIP programs) zip . cryptAlgorithm = ArchiveEntry . CRYPT_AE2 . toInt () // Configure encryption to use AES-256 zip . cryptAlgorithm = ArchiveEntry . CRYPT_AES_256 . toInt () }","title":"Configuring encryption"},{"location":"fileEncryption/#configuring-compression","text":"By default, the SDK chooses compression setting that balances speed with compressed size. However, it is possible to change the compression method. One might use a different compression algorithm , such as deflate, store, and LZMA, or specify a different compression level (higher for smaller ZIPs, lower for faster processing) as the application requires. Java import com.pkware.archive.ArchiveEntry ; import com.pkware.archive.zip.ZipArchiveOutput ; public static void compressionMethod ( ZipArchiveOutput zip ) { // Configure compression to use the deflate algorithm at level 6 zip . setCompressMethod ( ArchiveEntry . COMPRESS_METHOD_DEFLATE , 6 ); // Configure compression to use the store algorithm (no compression) zip . setCompressMethod ( ArchiveEntry . COMPRESS_METHOD_STORE ); } Kotlin import com.pkware.archive.ArchiveEntry import com.pkware.archive.zip.ZipArchiveOutput fun compressionMethod ( zip : ZipArchiveOutput ) { // Configure compression to use the deflate algorithm at level 6 zip . setCompressMethod ( ArchiveEntry . COMPRESS_METHOD_DEFLATE , 6 ) // Configure compression to use the store algorithm (no compression) zip . compressMethod = ArchiveEntry . COMPRESS_METHOD_STORE }","title":"Configuring compression"},{"location":"fileEncryption/#encryption","text":"Encryption using both passwords and Smartkeys is straightforward. See the Key Management docs for details on how to obtain a Smartkey. Java import com.pkware.archive.zip.ZipArchiveOutput ; import com.pkware.smartcrypt.keymanagement.smartkeys.Smartkey ; import com.pkware.smartcrypt.metaclient.MetaClientException ; import com.pkware.smartcrypt.unstructured.EncryptionSpec ; import com.pkware.smartcrypt.unstructured.UnstructuredData ; public static void contingencyGroupWithSmartkey ( UnstructuredData unstructured , Smartkey smartkey , // Create the ZIP as you normally would ZipArchiveOutput zip ) throws MetaClientException { EncryptionSpec spec = new EncryptionSpec (); // Optionally add a password here as well spec . smartkey = smartkey ; unstructured . encrypt ( zip , spec ); // Proceed to add files to the ZIP as you normally would } Kotlin import com.pkware.archive.zip.ZipArchiveOutput import com.pkware.smartcrypt.keymanagement.smartkeys.Smartkey import com.pkware.smartcrypt.metaclient.MetaClientException import com.pkware.smartcrypt.unstructured.EncryptionSpec import com.pkware.smartcrypt.unstructured.UnstructuredData @Throws ( MetaClientException :: class ) fun contingencyGroupWithSmartkey ( unstructured : UnstructuredData , smartkey : Smartkey , // Create the ZIP as you normally would zip : ZipArchiveOutput ) { val spec = EncryptionSpec () // Optionally add a password here as well spec . smartkey = smartkey ; unstructured . encrypt ( zip , spec ) // Proceed to add files to the ZIP as you normally would } Important In order for Smartcrypt Contingency Groups to apply, you must run your application as Smartcrypt.","title":"Encryption"},{"location":"fileEncryption/#contingency-group-without-smartkey","text":"The recommended way to gain access to the Contingency Group functionality of Smartcrypt is to use Smartkeys when encrypting. However, there may be some scenarios in which using a Smartkey is not an option. For these scenarios, we also provide the option of skipping the Smartkey, but still gaining the benefits of Contingency Groups. Java import com.pkware.archive.zip.ZipArchiveOutput ; import com.pkware.smartcrypt.metaclient.MetaClientException ; import com.pkware.smartcrypt.unstructured.EncryptionSpec ; import com.pkware.smartcrypt.unstructured.UnstructuredData ; public static void contingencyGroupWithoutSmartkey ( UnstructuredData unstructured , // Create the ZIP as you normally would ZipArchiveOutput zip ) throws MetaClientException { EncryptionSpec spec = new EncryptionSpec (); // The password must be provided if not specifying a Smartkey to gain contingency benefits spec . password = \"secret secret\" ; unstructured . encrypt ( zip , spec ); // Proceed to add files to the ZIP as you normally would } Kotlin import com.pkware.archive.zip.ZipArchiveOutput import com.pkware.smartcrypt.metaclient.MetaClientException import com.pkware.smartcrypt.unstructured.EncryptionSpec import com.pkware.smartcrypt.unstructured.UnstructuredData @Throws ( MetaClientException :: class ) fun contingencyGroupWithoutSmartkey ( unstructured : UnstructuredData , // Create the ZIP as you normally would zip : ZipArchiveOutput ) { val spec = EncryptionSpec () // The password must be provided if not specifying a Smartkey to gain contingency benefits spec . password = \"secret secret\" ; unstructured . encrypt ( zip , spec ) // Proceed to add files to the ZIP as you normally would } Important In order for Smartcrypt Contingency Groups to apply, you must run your application as Smartcrypt. See the [MetaClient Policy] docs for more details.","title":"Contingency group without Smartkey"},{"location":"fileEncryption/#decryption","text":"Once you have an UnstructuredData instance, decrypting ZIP archives encrypted using a Smartkey is easy! If you do not have access to the Smartkey, but are part of the Contingency Group, this snippet will also grant you access to the files. Java import com.pkware.archive.zip.ZipArchiveEntry ; import com.pkware.archive.zip.ZipFile ; import com.pkware.smartcrypt.unstructured.UnstructuredData ; import java.io.File ; import java.io.FileOutputStream ; import java.io.IOException ; import java.io.InputStream ; import java.io.OutputStream ; public static void decrypt ( UnstructuredData unstructuredData ) throws IOException { try ( ZipFile encrypted = unstructuredData . newZipFile ( new File ( \"encrypted.zip\" ))) { ZipArchiveEntry entry = encrypted . getEntry ( \"example.txt\" ); try ( OutputStream fileStream = new FileOutputStream ( \"example.txt\" )) { try ( InputStream decryptStream = encrypted . getInputStream ( entry )) { decryptStream . transferTo ( fileStream ); } } } } Kotlin import com.pkware.archive.zip.ZipArchiveEntry import com.pkware.archive.zip.ZipFile import com.pkware.smartcrypt.unstructured.UnstructuredData import java.io.File import java.io.FileOutputStream import java.io.IOException import java.io.InputStream import java.io.OutputStream @Throws ( IOException :: class ) fun decrypt ( unstructuredData : UnstructuredData ) { unstructuredData . newZipFile ( File ( \"encrypted.zip\" )). use { encrypted -> val entry = encrypted . getEntry ( \"example.txt\" ) FileOutputStream ( \"example.txt\" ). use { fileStream -> encrypted . getInputStream ( entry ). use { decryptStream -> decryptStream . transferTo ( fileStream ); } } } }","title":"Decryption"},{"location":"fileEncryption/installing/","text":"The binaries needed for the SDK are hosted in a Maven repository by PKWARE. Info The repository is password protected; contact PKWARE Sales and Support for access. Getting the packages \u00b6 Gradle Add the following to your repositories block maven { url 'https://packages.smartcrypt.com/repository/maven-public/' credentials { username 'Username issued by PKWARE to your company' password 'Password issued by PKWARE to your company' } } Then add the dependency dependencies { implementation ( \"com.pkware.smartcrypt:unstructured:2019.7.1\" ) } Maven Integrate the following into your pom.xml <repositories> <repository> <id> pkware </id> <name> PKWARE </name> <url> https://packages.smartcrypt.com/repository/maven-public/ </url> </repository> </repositories> <dependencies> <dependency> <groupId> com.pkware.smartcrypt </groupId> <artifactId> unstructured </artifactId> <version> 2019.7.1 </version> </dependency> </dependencies> Integrate the following into your ~/.m2/settings.xml <servers> <server> <id> pkware </id> <username> company_username </username> <password> company_password </password> </server> </servers> Manual If not using a maven-package compatible build system, or if unable to reach the PKWARE repository server via your build tool, you can download the JAR files manually. Navigate to https://packages.smartcrypt.com/#browse/browse:maven-public Sign in using your company\u2019s credentials Refresh the page. You should now be able to see the artifacts. Expand that target artifact all the way and download the JAR files needed Be sure to check the POM files for transitive dependencies and include those in your build as well Compatibility \u00b6 A Java 8 or higher JRE is required. The SDK includes native code, and therefore has system dependencies. PKWARE has confirmed that it works on the following platforms: MacOS Red Hat Enterprise Linux 6+ 64-bit SUSE Linux Enterprise Server 11+ Ubuntu 16.04+ 64-bit Windows 7 / Windows Server 2008 R2 64-bit The SDK is likely to run on other 64-bit GNU-based linux systems with libc version 2.12 or higher. Package Integrity \u00b6 The following checksums can be used if wanting to verify the integrity of the package and transitive dependencies published by PKWARE. unstructured-2019.7.1.jar \u00b6 SHA1: 27b4073b32564e3a471b602e8b02213d10095ac9 MD5: 51348df5a888ff0cee2ac1f8040d7e03","title":"Installing"},{"location":"fileEncryption/installing/#getting-the-packages","text":"Gradle Add the following to your repositories block maven { url 'https://packages.smartcrypt.com/repository/maven-public/' credentials { username 'Username issued by PKWARE to your company' password 'Password issued by PKWARE to your company' } } Then add the dependency dependencies { implementation ( \"com.pkware.smartcrypt:unstructured:2019.7.1\" ) } Maven Integrate the following into your pom.xml <repositories> <repository> <id> pkware </id> <name> PKWARE </name> <url> https://packages.smartcrypt.com/repository/maven-public/ </url> </repository> </repositories> <dependencies> <dependency> <groupId> com.pkware.smartcrypt </groupId> <artifactId> unstructured </artifactId> <version> 2019.7.1 </version> </dependency> </dependencies> Integrate the following into your ~/.m2/settings.xml <servers> <server> <id> pkware </id> <username> company_username </username> <password> company_password </password> </server> </servers> Manual If not using a maven-package compatible build system, or if unable to reach the PKWARE repository server via your build tool, you can download the JAR files manually. Navigate to https://packages.smartcrypt.com/#browse/browse:maven-public Sign in using your company\u2019s credentials Refresh the page. You should now be able to see the artifacts. Expand that target artifact all the way and download the JAR files needed Be sure to check the POM files for transitive dependencies and include those in your build as well","title":"Getting the packages"},{"location":"fileEncryption/installing/#compatibility","text":"A Java 8 or higher JRE is required. The SDK includes native code, and therefore has system dependencies. PKWARE has confirmed that it works on the following platforms: MacOS Red Hat Enterprise Linux 6+ 64-bit SUSE Linux Enterprise Server 11+ Ubuntu 16.04+ 64-bit Windows 7 / Windows Server 2008 R2 64-bit The SDK is likely to run on other 64-bit GNU-based linux systems with libc version 2.12 or higher.","title":"Compatibility"},{"location":"fileEncryption/installing/#package-integrity","text":"The following checksums can be used if wanting to verify the integrity of the package and transitive dependencies published by PKWARE.","title":"Package Integrity"},{"location":"fileEncryption/installing/#unstructured-201971jar","text":"SHA1: 27b4073b32564e3a471b602e8b02213d10095ac9 MD5: 51348df5a888ff0cee2ac1f8040d7e03","title":"unstructured-2019.7.1.jar"},{"location":"fileEncryption/zipDetails/","text":"Zip file details \u00b6 The Zip format was designed for efficient extraction operations. As a result, the layout places \u201csummary\u201d headers about the compressed content before the content itself. The tradeoff is that it is necessary to seek backwards in a data stream during archive creation Entry names and paths \u00b6 Every entry in a Zip is stored using an absolute path relative to the base of the archive. Zip archives cannot have multiple entries with the same name.","title":"Zip file details"},{"location":"fileEncryption/zipDetails/#zip-file-details","text":"The Zip format was designed for efficient extraction operations. As a result, the layout places \u201csummary\u201d headers about the compressed content before the content itself. The tradeoff is that it is necessary to seek backwards in a data stream during archive creation","title":"Zip file details"},{"location":"fileEncryption/zipDetails/#entry-names-and-paths","text":"Every entry in a Zip is stored using an absolute path relative to the base of the archive. Zip archives cannot have multiple entries with the same name.","title":"Entry names and paths"},{"location":"keyManagement/","text":"Key management \u00b6 The key management component allows for querying, modifying, and creating Smartkeys. Setup \u00b6 Java import com.pkware.smartcrypt.keymanagement.SmartcryptKeyManagement ; import com.pkware.smartcrypt.keymanagement.SmartcryptKeyManagementImpl ; import com.pkware.smartcrypt.metaclient.MetaClient ; public static SmartcryptKeyManagement setup ( MetaClient metaClient ) { return new SmartcryptKeyManagementImpl . Builder () . metaClient ( metaClient ) // TODO Optionally provide a PersistenceCallback, if you want the SDK to work while offline. You need to implement this class yourself. . persistenceCallback ( new FileSystemPersistenceCallback ()) . build (); } Kotlin import com.pkware.smartcrypt.keymanagement.SmartcryptKeyManagement import com.pkware.smartcrypt.keymanagement.SmartcryptKeyManagementImpl import com.pkware.smartcrypt.metaclient.MetaClient fun MetaClient . newSmartcryptKeyManagement (): SmartcryptKeyManagement = SmartcryptKeyManagementImpl . Builder () . metaClient ( this ) // TODO Optionally provide a PersistenceCallback, if you want the SDK to work while offline. You need to implement this class yourself. . persistenceCallback ( new FileSystemPersistenceCallback ()) . build () Lifecycle \u00b6 A single instance of SmartcryptKeyManagement should generally be treated as a singleton by your application. You typically want all operations to use that one instance. Using multiple instances will not cause problems, but will consume a lot more system resources, as more threads and background processes will get used. Login \u00b6 There are two types of accounts in Smartcrypt: Managed and Unmanaged. A Managed account is one that is tied to an identity system like Active Directory. An Unmanaged account exists only in the PKWARE Enterprise Manager. For the most part, the two account types work the same way, but during login, different calls have to be made based on the type of the account. Unmanaged accounts need to log in with [loginUnManagedAccount], while Managed accounts can choose between a regular login using a username/password combo, and a single sign-on style login, using Kerberos or Integrated Windows Authentication (IWA). Login unmanaged account Java import com.pkware.smartcrypt.keymanagement.AccountManagement ; import com.pkware.smartcrypt.keymanagement.SmartcryptKeyManagement ; public static void loginUnmanaged ( SmartcryptKeyManagement keyManagement , String emailAddress , String password ) { AccountManagement accountManagement = keyManagement . getAccountManagement (); accountManagement . loginUnManagedAccount ( emailAddress , password ); } Kotlin import com.pkware.smartcrypt.keymanagement.SmartcryptKeyManagement fun loginUnmanaged ( keyManagement : SmartcryptKeyManagement , emailAddress : String , password : String ) { val accountManagement = keyManagement . getAccountManagement () accountManagement . loginUnManagedAccount ( emailAddress , password ) } Login managed account \u00b6 For a managed account, you have to choose between a password-based login and single sign-on. The password based approach is recommended during development as it is significantly easier to set up, but single sign-on typically provides a better deployment process for production scenarios. Login managed account with password Java import com.pkware.smartcrypt.keymanagement.AccountManagement ; import com.pkware.smartcrypt.keymanagement.SmartcryptKeyManagement ; public static void loginManaged ( SmartcryptKeyManagement keyManagement , String emailAddress , String password ) { AccountManagement accountManagement = keyManagement . getAccountManagement (); accountManagement . loginManagedAccount ( emailAddress , password ); } Kotlin import com.pkware.smartcrypt.keymanagement.SmartcryptKeyManagement fun loginManaged ( keyManagement : SmartcryptKeyManagement , emailAddress : String , password : String ) { val accountManagement = keyManagement . getAccountManagement () accountManagement . loginManagedAccount ( emailAddress , password ) } Single sign-on \u00b6 The Smartcrypt SDK supports single sign-on login flows for managed users on Windows and unix through a mechanism called Implicit Login. Login managed account with single sign-on Java import com.pkware.smartcrypt.keymanagement.AccountManagement ; import com.pkware.smartcrypt.keymanagement.SmartcryptKeyManagement ; public static void loginSingleSignOn ( SmartcryptKeyManagement keyManagement ) { AccountManagement accountManagement = keyManagement . getAccountManagement (); accountManagement . loginImplicitAccount (); } Kotlin import com.pkware.smartcrypt.keymanagement.SmartcryptKeyManagement fun loginSingleSignOn ( keyManagement : SmartcryptKeyManagement ) { val accountManagement = keyManagement . getAccountManagement () accountManagement . loginImplicitAccount () } Advantages of Implicit Login \u00b6 Several features make Implicit Login the recommended authentication mechanism. For back-office applications, Implicit Login provides the convenience of not needing to hard code, manually enter or place the credentials into a configuration file. This improves security and makes it easier to deploy applications. For end-user applications, companies typically want the end user to login with domain credentials when running the application. In this case, Implicit Login affords the ability to skip a login prompt, enabling a seamless user experience. This is particularly desirable when modifying existing business applications to incorporate Smartcrypt data protection. How it works \u00b6 On Windows, Integrated Windows Authentication (IWA) is used. The identity of the Active Directory Domain User who launches the process using the Smartcrypt SDK is used. On MacOS and Linux, the Kerberos system is used to identify and authenticate the user. Domain-joined MacOS installations are automatically configured. On Linux, the kinit program is used. When properly configured, Linux machines will automatically run kinit when users perform a password-based system login. On MacOS and Linux, the JVM must be configured to correctly integrate with the Kerberos system. Which Active Directory Domain User identity is used depends on the configuration. Configuring the JVM \u00b6 The simplest way to get started is to set the java.security.krb5.realm and java.security.krb5.kdc system properties: Java public static void setupKerberos () { // Provide the Kerberos realm that your user is in System . setProperty ( \"java.security.krb5.realm\" , \"EXAMPLE.COM\" ); // Provide the name of a Kerberos ticketing server System . setProperty ( \"java.security.krb5.kdc\" , \"dc01.example.com\" ); } Kotlin fun setupKerberos () { // Provide the Kerberos realm that your user is in System . setProperty ( \"java.security.krb5.realm\" , \"EXAMPLE.COM\" ) // Provide the name of a Kerberos ticketing server System . setProperty ( \"java.security.krb5.kdc\" , \"dc01.example.com\" ) } For a production rollout, you should set the java.security.krb5.conf system property to point at the krb5.conf on the host system. Consult your Kerberos or Windows Domain Administrator for more information on the details of your Kerberos environment. Diagnosing JVM problems \u00b6 To start, ensure that you can successfully acquire a Kerberos TGT with the kinit utility. When this is successful, proceed. The Smartcrypt SDK has a built-in diagnostic utility. To activate it Set the logging level to TRACE Run the java command with the flag -Djava.security.debug=net,gssloginconfig,configfile,configparser,logincontext to enable detailed JVM logging Call MetaClient#loginImplicitAccount() . This will cause the utility to write diagnostics to the configured Logger . The diagnostic utility will inspect your current configuration for common problems. The additional logging may be helpful in determining how the JVM is interpreting the current Kerberos setup. Create Smartkey \u00b6 Java import com.pkware.smartcrypt.keymanagement.SmartcryptKeyManagement ; import com.pkware.smartcrypt.keymanagement.SmartkeySpec ; import com.pkware.smartcrypt.keymanagement.Smartkeys ; import com.pkware.smartcrypt.keymanagement.smartkeys.Smartkey ; import io.reactivex.Observable ; public static void createSmartkey ( SmartcryptKeyManagement keyManagement ) { Smartkeys smartkeys = keyManagement . getSmartkeys (); // To create a new Smartkey, prepare a SmartkeySpec with the information for the new key. SmartkeySpec createSmartkeySpec = new SmartkeySpec (); createSmartkeySpec . name = \"Sample\" ; createSmartkeySpec . addAccess . add ( \"john.doe@example.com\" ); // Key creation is synchronous, but you can be notified of updates to the key by listening to the Observable Observable < Smartkey > keyObservable = smartkeys . create ( createSmartkeySpec ); Smartkey smartkey = keyObservable . doOnEach ( genericSmartkeyNotification -> { Smartkey key = genericSmartkeyNotification . getValue (); System . out . println ( \"Got revision \" + key . getRevision () + \" for created Smartkey \" + key . getName ()); }) . blockingSingle (); } Kotlin import com.pkware.smartcrypt.keymanagement.SmartcryptKeyManagement import com.pkware.smartcrypt.keymanagement.SmartkeySpec fun createSmartkey ( keyManagement : SmartcryptKeyManagement ) { val smartkeys = keyManagement . smartkeys // To create a new Smartkey, prepare a SmartkeySpec with the information for the new key. val createSmartkeySpec = SmartkeySpec () createSmartkeySpec . name = \"Sample\" createSmartkeySpec . addAccess . add ( \"john.doe@example.com\" ) // Key creation is synchronous, but you can be notified of updates to the key by listening to the Observable val keyObservable = smartkeys . create ( createSmartkeySpec ) val smartkey = keyObservable . doOnEach { genericSmartkeyNotification -> val key = genericSmartkeyNotification . value println ( \"Got revision ${key!!.revision} for created Smartkey ${key.name}\" ) } . blockingSingle () } Update Smartkey \u00b6 To update a key, once again prepare a SmartkeySpec . Most types of keys can be updated in some fashion. Java import com.pkware.smartcrypt.keymanagement.SmartcryptKeyManagement ; import com.pkware.smartcrypt.keymanagement.SmartkeySpec ; import com.pkware.smartcrypt.keymanagement.Smartkeys ; import com.pkware.smartcrypt.keymanagement.smartkeys.Smartkey ; import io.reactivex.Observable ; public static void updateSmartkey ( SmartcryptKeyManagement keyManagement , Smartkey smartkey ) { Smartkeys smartkeys = keyManagement . getSmartkeys (); SmartkeySpec updateSmartkeySpec = new SmartkeySpec (); updateSmartkeySpec . name = \"Updated Sample\" ; updateSmartkeySpec . removeAccess . add ( \"john.doe@example.com\" ); // Key updates are synchronous, but you can be notified of updates to the key by listening to the Observable Observable < Smartkey > updatedKeyObservable = smartkeys . update ( smartkey , updateSmartkeySpec ); updatedKeyObservable . subscribe ( key -> System . out . println ( \"Got updated Smartkey \" + key . getName ())); } Kotlin import com.pkware.smartcrypt.keymanagement.SmartcryptKeyManagement import com.pkware.smartcrypt.keymanagement.SmartkeySpec import com.pkware.smartcrypt.keymanagement.smartkeys.Smartkey fun updateSmartkey ( keyManagement : SmartcryptKeyManagement , smartkey : Smartkey ) { val smartkeys = keyManagement . smartkeys val updateSmartkeySpec = SmartkeySpec () updateSmartkeySpec . name = \"Updated Sample\" updateSmartkeySpec . removeAccess . add ( \"john.doe@example.com\" ) // Key updates are synchronous, but you can be notified of updates to the key by listening to the Observable val updatedKeyObservable = smartkeys . update ( smartkey , updateSmartkeySpec ) updatedKeyObservable . subscribe { key -> println ( \"Got updated Smartkey ${key.name}\" ) } } Working offline \u00b6 By default, the SDK stores key and account information in-memory. In this configuration, the application will be able to use Smartkeys offline only until the process dies. Then, if the device is offline when the application again starts up, it will not have access to Smartkeys and account data. Often it is desireable for an application to continue working under these conditions. In that case, it is essential that account data get saved for offline use. The mechanism in the SDK to provide hooks for saving data is called the PersistenceCallback . The PersistenceCallback is invoked by the SDK with the data modifications that need to be made. You must implement a PersistenceCallback of your own - the SDK does not come with an implementation. Note Be sure to review the PersistenceCallback documentation when implementing your own class. Java import com.pkware.smartcrypt.keymanagement.PersistenceCallback ; import com.pkware.smartcrypt.keymanagement.SmartcryptKeyManagementImpl ; import java.io.BufferedWriter ; import java.io.IOException ; import java.nio.file.Files ; import java.nio.file.Paths ; import java.util.Collections ; import java.util.Map ; import java.util.Set ; import static java.util.stream.Collectors.toMap ; public static SmartcryptKeyManagementImpl . Builder configureDataPersistence ( SmartcryptKeyManagementImpl . Builder builder ) { // It is up to you how you store your data. In files, in a database, on the network, etc. return builder . persistenceCallback ( new FilePersistenceCallback ()); } // Note: This class is not part of the SDK class FilePersistenceCallback implements PersistenceCallback { private final static String folder = \"serializedSmartcryptData\" ; @Override public boolean onSaveData ( Map < String , String > toSave , Set < String > toDelete ) { try { Files . createDirectory ( Paths . get ( folder )); for ( Map . Entry < String , String > datum : toSave . entrySet ()) { try ( BufferedWriter writer = Files . newBufferedWriter ( Paths . get ( folder , datum . getKey ()))) { writer . write ( datum . getValue ()); } } for ( String name : toDelete ) { Files . deleteIfExists ( Paths . get ( folder , name )); } return true ; } catch ( IOException e ) { return false ; } } @Override public Map < String , String > onLoadData () { try ( Stream < Path > stream = Files . list ( Paths . get ( folder ))) { return stream . collect ( toMap ( path -> path . getFileName (). toString (), // Key fileName -> { // Value try { return new String ( Files . readAllBytes ( fileName )); } catch ( IOException e ) { e . printStackTrace (); return \"\" ; } } )); } catch ( IOException e ) { return Collections . emptyMap (); } } } Kotlin import com.pkware.smartcrypt.keymanagement.PersistenceCallback import com.pkware.smartcrypt.keymanagement.SmartcryptKeyManagementImpl import java.io.IOException import java.nio.file.Files import java.nio.file.Paths import java.util.stream.Collectors.toMap fun configureDataPersistence ( builder : SmartcryptKeyManagementImpl . Builder ): SmartcryptKeyManagementImpl . Builder { // It is up to you how you store your data. In files, in a database, on the network, etc. return builder . persistenceCallback ( FilePersistenceCallback ()) } // Note: This class is not part of the SDK class FilePersistenceCallback : PersistenceCallback { private val folder = \"serializedSmartcryptData\" override fun onSaveData ( toSave : Map < String , String > , toDelete : Set < String > ): Boolean = try { Files . createDirectory ( Paths . get ( folder )) for (( key , value ) in toSave ) { Files . newBufferedWriter ( Paths . get ( folder , key )). use { writer -> writer . write ( value ) } } for ( name in toDelete ) { Files . deleteIfExists ( Paths . get ( folder , name )) } true } catch ( e : IOException ) { false } override fun onLoadData (): Map < String , String > = try { Files . list ( Paths . get ( folder )). use { stream -> stream . collect ( toMap ( { path -> path . fileName . toString () }, // Key { fileName -> // Value return @toMap try { String ( Files . readAllBytes ( fileName )) } catch ( e : IOException ) { e . printStackTrace () \"\" } } )) } } catch ( e : IOException ) { emptyMap () } } Once your PersistenceCallback is configured, you must modify your application to restore data into the SDK when it starts up. Java import com.pkware.smartcrypt.keymanagement.DataStorage ; import com.pkware.smartcrypt.keymanagement.SmartcryptKeyManagement ; public static void restoreSmartcryptData ( SmartcryptKeyManagement keyManagement ) { DataStorage dataStorage = keyManagement . getDataStorage (); // This causes the SDK to call your PersistenceCallback to load data // You control both the threading and timing of how data are restored dataStorage . restore (); } Kotlin import com.pkware.smartcrypt.keymanagement.SmartcryptKeyManagement fun restoreSmartcryptData ( keyManagement : SmartcryptKeyManagement ) { val dataStorage = keyManagement . getDataStorage (); // This causes the SDK to call your PersistenceCallback to load data. // You control both the threading and timing of how data are restored dataStorage . restore (); }","title":"Overview"},{"location":"keyManagement/#key-management","text":"The key management component allows for querying, modifying, and creating Smartkeys.","title":"Key management"},{"location":"keyManagement/#setup","text":"Java import com.pkware.smartcrypt.keymanagement.SmartcryptKeyManagement ; import com.pkware.smartcrypt.keymanagement.SmartcryptKeyManagementImpl ; import com.pkware.smartcrypt.metaclient.MetaClient ; public static SmartcryptKeyManagement setup ( MetaClient metaClient ) { return new SmartcryptKeyManagementImpl . Builder () . metaClient ( metaClient ) // TODO Optionally provide a PersistenceCallback, if you want the SDK to work while offline. You need to implement this class yourself. . persistenceCallback ( new FileSystemPersistenceCallback ()) . build (); } Kotlin import com.pkware.smartcrypt.keymanagement.SmartcryptKeyManagement import com.pkware.smartcrypt.keymanagement.SmartcryptKeyManagementImpl import com.pkware.smartcrypt.metaclient.MetaClient fun MetaClient . newSmartcryptKeyManagement (): SmartcryptKeyManagement = SmartcryptKeyManagementImpl . Builder () . metaClient ( this ) // TODO Optionally provide a PersistenceCallback, if you want the SDK to work while offline. You need to implement this class yourself. . persistenceCallback ( new FileSystemPersistenceCallback ()) . build ()","title":"Setup"},{"location":"keyManagement/#lifecycle","text":"A single instance of SmartcryptKeyManagement should generally be treated as a singleton by your application. You typically want all operations to use that one instance. Using multiple instances will not cause problems, but will consume a lot more system resources, as more threads and background processes will get used.","title":"Lifecycle"},{"location":"keyManagement/#login","text":"There are two types of accounts in Smartcrypt: Managed and Unmanaged. A Managed account is one that is tied to an identity system like Active Directory. An Unmanaged account exists only in the PKWARE Enterprise Manager. For the most part, the two account types work the same way, but during login, different calls have to be made based on the type of the account. Unmanaged accounts need to log in with [loginUnManagedAccount], while Managed accounts can choose between a regular login using a username/password combo, and a single sign-on style login, using Kerberos or Integrated Windows Authentication (IWA). Login unmanaged account Java import com.pkware.smartcrypt.keymanagement.AccountManagement ; import com.pkware.smartcrypt.keymanagement.SmartcryptKeyManagement ; public static void loginUnmanaged ( SmartcryptKeyManagement keyManagement , String emailAddress , String password ) { AccountManagement accountManagement = keyManagement . getAccountManagement (); accountManagement . loginUnManagedAccount ( emailAddress , password ); } Kotlin import com.pkware.smartcrypt.keymanagement.SmartcryptKeyManagement fun loginUnmanaged ( keyManagement : SmartcryptKeyManagement , emailAddress : String , password : String ) { val accountManagement = keyManagement . getAccountManagement () accountManagement . loginUnManagedAccount ( emailAddress , password ) }","title":"Login"},{"location":"keyManagement/#login-managed-account","text":"For a managed account, you have to choose between a password-based login and single sign-on. The password based approach is recommended during development as it is significantly easier to set up, but single sign-on typically provides a better deployment process for production scenarios. Login managed account with password Java import com.pkware.smartcrypt.keymanagement.AccountManagement ; import com.pkware.smartcrypt.keymanagement.SmartcryptKeyManagement ; public static void loginManaged ( SmartcryptKeyManagement keyManagement , String emailAddress , String password ) { AccountManagement accountManagement = keyManagement . getAccountManagement (); accountManagement . loginManagedAccount ( emailAddress , password ); } Kotlin import com.pkware.smartcrypt.keymanagement.SmartcryptKeyManagement fun loginManaged ( keyManagement : SmartcryptKeyManagement , emailAddress : String , password : String ) { val accountManagement = keyManagement . getAccountManagement () accountManagement . loginManagedAccount ( emailAddress , password ) }","title":"Login managed account"},{"location":"keyManagement/#single-sign-on","text":"The Smartcrypt SDK supports single sign-on login flows for managed users on Windows and unix through a mechanism called Implicit Login. Login managed account with single sign-on Java import com.pkware.smartcrypt.keymanagement.AccountManagement ; import com.pkware.smartcrypt.keymanagement.SmartcryptKeyManagement ; public static void loginSingleSignOn ( SmartcryptKeyManagement keyManagement ) { AccountManagement accountManagement = keyManagement . getAccountManagement (); accountManagement . loginImplicitAccount (); } Kotlin import com.pkware.smartcrypt.keymanagement.SmartcryptKeyManagement fun loginSingleSignOn ( keyManagement : SmartcryptKeyManagement ) { val accountManagement = keyManagement . getAccountManagement () accountManagement . loginImplicitAccount () }","title":"Single sign-on"},{"location":"keyManagement/#advantages-of-implicit-login","text":"Several features make Implicit Login the recommended authentication mechanism. For back-office applications, Implicit Login provides the convenience of not needing to hard code, manually enter or place the credentials into a configuration file. This improves security and makes it easier to deploy applications. For end-user applications, companies typically want the end user to login with domain credentials when running the application. In this case, Implicit Login affords the ability to skip a login prompt, enabling a seamless user experience. This is particularly desirable when modifying existing business applications to incorporate Smartcrypt data protection.","title":"Advantages of Implicit Login"},{"location":"keyManagement/#how-it-works","text":"On Windows, Integrated Windows Authentication (IWA) is used. The identity of the Active Directory Domain User who launches the process using the Smartcrypt SDK is used. On MacOS and Linux, the Kerberos system is used to identify and authenticate the user. Domain-joined MacOS installations are automatically configured. On Linux, the kinit program is used. When properly configured, Linux machines will automatically run kinit when users perform a password-based system login. On MacOS and Linux, the JVM must be configured to correctly integrate with the Kerberos system. Which Active Directory Domain User identity is used depends on the configuration.","title":"How it works"},{"location":"keyManagement/#configuring-the-jvm","text":"The simplest way to get started is to set the java.security.krb5.realm and java.security.krb5.kdc system properties: Java public static void setupKerberos () { // Provide the Kerberos realm that your user is in System . setProperty ( \"java.security.krb5.realm\" , \"EXAMPLE.COM\" ); // Provide the name of a Kerberos ticketing server System . setProperty ( \"java.security.krb5.kdc\" , \"dc01.example.com\" ); } Kotlin fun setupKerberos () { // Provide the Kerberos realm that your user is in System . setProperty ( \"java.security.krb5.realm\" , \"EXAMPLE.COM\" ) // Provide the name of a Kerberos ticketing server System . setProperty ( \"java.security.krb5.kdc\" , \"dc01.example.com\" ) } For a production rollout, you should set the java.security.krb5.conf system property to point at the krb5.conf on the host system. Consult your Kerberos or Windows Domain Administrator for more information on the details of your Kerberos environment.","title":"Configuring the JVM"},{"location":"keyManagement/#diagnosing-jvm-problems","text":"To start, ensure that you can successfully acquire a Kerberos TGT with the kinit utility. When this is successful, proceed. The Smartcrypt SDK has a built-in diagnostic utility. To activate it Set the logging level to TRACE Run the java command with the flag -Djava.security.debug=net,gssloginconfig,configfile,configparser,logincontext to enable detailed JVM logging Call MetaClient#loginImplicitAccount() . This will cause the utility to write diagnostics to the configured Logger . The diagnostic utility will inspect your current configuration for common problems. The additional logging may be helpful in determining how the JVM is interpreting the current Kerberos setup.","title":"Diagnosing JVM problems"},{"location":"keyManagement/#create-smartkey","text":"Java import com.pkware.smartcrypt.keymanagement.SmartcryptKeyManagement ; import com.pkware.smartcrypt.keymanagement.SmartkeySpec ; import com.pkware.smartcrypt.keymanagement.Smartkeys ; import com.pkware.smartcrypt.keymanagement.smartkeys.Smartkey ; import io.reactivex.Observable ; public static void createSmartkey ( SmartcryptKeyManagement keyManagement ) { Smartkeys smartkeys = keyManagement . getSmartkeys (); // To create a new Smartkey, prepare a SmartkeySpec with the information for the new key. SmartkeySpec createSmartkeySpec = new SmartkeySpec (); createSmartkeySpec . name = \"Sample\" ; createSmartkeySpec . addAccess . add ( \"john.doe@example.com\" ); // Key creation is synchronous, but you can be notified of updates to the key by listening to the Observable Observable < Smartkey > keyObservable = smartkeys . create ( createSmartkeySpec ); Smartkey smartkey = keyObservable . doOnEach ( genericSmartkeyNotification -> { Smartkey key = genericSmartkeyNotification . getValue (); System . out . println ( \"Got revision \" + key . getRevision () + \" for created Smartkey \" + key . getName ()); }) . blockingSingle (); } Kotlin import com.pkware.smartcrypt.keymanagement.SmartcryptKeyManagement import com.pkware.smartcrypt.keymanagement.SmartkeySpec fun createSmartkey ( keyManagement : SmartcryptKeyManagement ) { val smartkeys = keyManagement . smartkeys // To create a new Smartkey, prepare a SmartkeySpec with the information for the new key. val createSmartkeySpec = SmartkeySpec () createSmartkeySpec . name = \"Sample\" createSmartkeySpec . addAccess . add ( \"john.doe@example.com\" ) // Key creation is synchronous, but you can be notified of updates to the key by listening to the Observable val keyObservable = smartkeys . create ( createSmartkeySpec ) val smartkey = keyObservable . doOnEach { genericSmartkeyNotification -> val key = genericSmartkeyNotification . value println ( \"Got revision ${key!!.revision} for created Smartkey ${key.name}\" ) } . blockingSingle () }","title":"Create Smartkey"},{"location":"keyManagement/#update-smartkey","text":"To update a key, once again prepare a SmartkeySpec . Most types of keys can be updated in some fashion. Java import com.pkware.smartcrypt.keymanagement.SmartcryptKeyManagement ; import com.pkware.smartcrypt.keymanagement.SmartkeySpec ; import com.pkware.smartcrypt.keymanagement.Smartkeys ; import com.pkware.smartcrypt.keymanagement.smartkeys.Smartkey ; import io.reactivex.Observable ; public static void updateSmartkey ( SmartcryptKeyManagement keyManagement , Smartkey smartkey ) { Smartkeys smartkeys = keyManagement . getSmartkeys (); SmartkeySpec updateSmartkeySpec = new SmartkeySpec (); updateSmartkeySpec . name = \"Updated Sample\" ; updateSmartkeySpec . removeAccess . add ( \"john.doe@example.com\" ); // Key updates are synchronous, but you can be notified of updates to the key by listening to the Observable Observable < Smartkey > updatedKeyObservable = smartkeys . update ( smartkey , updateSmartkeySpec ); updatedKeyObservable . subscribe ( key -> System . out . println ( \"Got updated Smartkey \" + key . getName ())); } Kotlin import com.pkware.smartcrypt.keymanagement.SmartcryptKeyManagement import com.pkware.smartcrypt.keymanagement.SmartkeySpec import com.pkware.smartcrypt.keymanagement.smartkeys.Smartkey fun updateSmartkey ( keyManagement : SmartcryptKeyManagement , smartkey : Smartkey ) { val smartkeys = keyManagement . smartkeys val updateSmartkeySpec = SmartkeySpec () updateSmartkeySpec . name = \"Updated Sample\" updateSmartkeySpec . removeAccess . add ( \"john.doe@example.com\" ) // Key updates are synchronous, but you can be notified of updates to the key by listening to the Observable val updatedKeyObservable = smartkeys . update ( smartkey , updateSmartkeySpec ) updatedKeyObservable . subscribe { key -> println ( \"Got updated Smartkey ${key.name}\" ) } }","title":"Update Smartkey"},{"location":"keyManagement/#working-offline","text":"By default, the SDK stores key and account information in-memory. In this configuration, the application will be able to use Smartkeys offline only until the process dies. Then, if the device is offline when the application again starts up, it will not have access to Smartkeys and account data. Often it is desireable for an application to continue working under these conditions. In that case, it is essential that account data get saved for offline use. The mechanism in the SDK to provide hooks for saving data is called the PersistenceCallback . The PersistenceCallback is invoked by the SDK with the data modifications that need to be made. You must implement a PersistenceCallback of your own - the SDK does not come with an implementation. Note Be sure to review the PersistenceCallback documentation when implementing your own class. Java import com.pkware.smartcrypt.keymanagement.PersistenceCallback ; import com.pkware.smartcrypt.keymanagement.SmartcryptKeyManagementImpl ; import java.io.BufferedWriter ; import java.io.IOException ; import java.nio.file.Files ; import java.nio.file.Paths ; import java.util.Collections ; import java.util.Map ; import java.util.Set ; import static java.util.stream.Collectors.toMap ; public static SmartcryptKeyManagementImpl . Builder configureDataPersistence ( SmartcryptKeyManagementImpl . Builder builder ) { // It is up to you how you store your data. In files, in a database, on the network, etc. return builder . persistenceCallback ( new FilePersistenceCallback ()); } // Note: This class is not part of the SDK class FilePersistenceCallback implements PersistenceCallback { private final static String folder = \"serializedSmartcryptData\" ; @Override public boolean onSaveData ( Map < String , String > toSave , Set < String > toDelete ) { try { Files . createDirectory ( Paths . get ( folder )); for ( Map . Entry < String , String > datum : toSave . entrySet ()) { try ( BufferedWriter writer = Files . newBufferedWriter ( Paths . get ( folder , datum . getKey ()))) { writer . write ( datum . getValue ()); } } for ( String name : toDelete ) { Files . deleteIfExists ( Paths . get ( folder , name )); } return true ; } catch ( IOException e ) { return false ; } } @Override public Map < String , String > onLoadData () { try ( Stream < Path > stream = Files . list ( Paths . get ( folder ))) { return stream . collect ( toMap ( path -> path . getFileName (). toString (), // Key fileName -> { // Value try { return new String ( Files . readAllBytes ( fileName )); } catch ( IOException e ) { e . printStackTrace (); return \"\" ; } } )); } catch ( IOException e ) { return Collections . emptyMap (); } } } Kotlin import com.pkware.smartcrypt.keymanagement.PersistenceCallback import com.pkware.smartcrypt.keymanagement.SmartcryptKeyManagementImpl import java.io.IOException import java.nio.file.Files import java.nio.file.Paths import java.util.stream.Collectors.toMap fun configureDataPersistence ( builder : SmartcryptKeyManagementImpl . Builder ): SmartcryptKeyManagementImpl . Builder { // It is up to you how you store your data. In files, in a database, on the network, etc. return builder . persistenceCallback ( FilePersistenceCallback ()) } // Note: This class is not part of the SDK class FilePersistenceCallback : PersistenceCallback { private val folder = \"serializedSmartcryptData\" override fun onSaveData ( toSave : Map < String , String > , toDelete : Set < String > ): Boolean = try { Files . createDirectory ( Paths . get ( folder )) for (( key , value ) in toSave ) { Files . newBufferedWriter ( Paths . get ( folder , key )). use { writer -> writer . write ( value ) } } for ( name in toDelete ) { Files . deleteIfExists ( Paths . get ( folder , name )) } true } catch ( e : IOException ) { false } override fun onLoadData (): Map < String , String > = try { Files . list ( Paths . get ( folder )). use { stream -> stream . collect ( toMap ( { path -> path . fileName . toString () }, // Key { fileName -> // Value return @toMap try { String ( Files . readAllBytes ( fileName )) } catch ( e : IOException ) { e . printStackTrace () \"\" } } )) } } catch ( e : IOException ) { emptyMap () } } Once your PersistenceCallback is configured, you must modify your application to restore data into the SDK when it starts up. Java import com.pkware.smartcrypt.keymanagement.DataStorage ; import com.pkware.smartcrypt.keymanagement.SmartcryptKeyManagement ; public static void restoreSmartcryptData ( SmartcryptKeyManagement keyManagement ) { DataStorage dataStorage = keyManagement . getDataStorage (); // This causes the SDK to call your PersistenceCallback to load data // You control both the threading and timing of how data are restored dataStorage . restore (); } Kotlin import com.pkware.smartcrypt.keymanagement.SmartcryptKeyManagement fun restoreSmartcryptData ( keyManagement : SmartcryptKeyManagement ) { val dataStorage = keyManagement . getDataStorage (); // This causes the SDK to call your PersistenceCallback to load data. // You control both the threading and timing of how data are restored dataStorage . restore (); }","title":"Working offline"},{"location":"keyManagement/installing/","text":"The binaries needed for the SDK are hosted in a Maven repository by PKWARE. Info The repository is password protected; contact PKWARE Sales and Support for access. Getting the packages \u00b6 Gradle Add the following to your repositories block maven { url 'https://packages.smartcrypt.com/repository/maven-public/' credentials { username 'Username issued by PKWARE to your company' password 'Password issued by PKWARE to your company' } } Then add the dependency dependencies { implementation ( \"com.pkware.smartcrypt:key-management:2019.7.1\" ) } Maven Integrate the following into your pom.xml <repositories> <repository> <id> pkware </id> <name> PKWARE </name> <url> https://packages.smartcrypt.com/repository/maven-public/ </url> </repository> </repositories> <dependencies> <dependency> <groupId> com.pkware.smartcrypt </groupId> <artifactId> key-management </artifactId> <version> 2019.7.1 </version> </dependency> </dependencies> Integrate the following into your ~/.m2/settings.xml <servers> <server> <id> pkware </id> <username> company_username </username> <password> company_password </password> </server> </servers> Manual If not using a maven-package compatible build system, or if unable to reach the PKWARE repository server via your build tool, you can download the JAR files manually. Navigate to https://packages.smartcrypt.com/#browse/browse:maven-public Sign in using your company\u2019s credentials Refresh the page. You should now be able to see the artifacts. Expand that target artifact all the way and download the JAR files needed Be sure to check the POM files for transitive dependencies and include those in your build as well Compatibility \u00b6 A Java 8 or higher JRE is required. The SDK includes native code, and therefore has system dependencies. PKWARE has confirmed that it works on the following platforms: MacOS Red Hat Enterprise Linux 6+ 64-bit SUSE Linux Enterprise Server 11+ Ubuntu 16.04+ 64-bit Windows 7 / Windows Server 2008 R2 64-bit The SDK is likely to run on other 64-bit GNU-based linux systems with libc version 2.12 or higher. Package Integrity \u00b6 The following checksums can be used if wanting to verify the integrity of the package and transitive dependencies published by PKWARE. metaclient-2019.7.1.jar \u00b6 SHA1: b6d2e79b1a5329ece7fa8c576e77600e5175c2de MD5: 36e860184faea2f0c18fe39c6d8db8ed metaclient-jvm-2019.7.1.jar \u00b6 SHA1: 0d5807beb3c473c5d0efeff20e9a80af13b6757d MD5: 584d4d2b9ca62d545c4f7f10f7e617ed key-management-2019.7.1.jar \u00b6 SHA1: c0183b0914b749f060e31ed815b4fdb26bc108fa MD5: f88b0c9ebf8947d4ad944faaf841b736","title":"Installing"},{"location":"keyManagement/installing/#getting-the-packages","text":"Gradle Add the following to your repositories block maven { url 'https://packages.smartcrypt.com/repository/maven-public/' credentials { username 'Username issued by PKWARE to your company' password 'Password issued by PKWARE to your company' } } Then add the dependency dependencies { implementation ( \"com.pkware.smartcrypt:key-management:2019.7.1\" ) } Maven Integrate the following into your pom.xml <repositories> <repository> <id> pkware </id> <name> PKWARE </name> <url> https://packages.smartcrypt.com/repository/maven-public/ </url> </repository> </repositories> <dependencies> <dependency> <groupId> com.pkware.smartcrypt </groupId> <artifactId> key-management </artifactId> <version> 2019.7.1 </version> </dependency> </dependencies> Integrate the following into your ~/.m2/settings.xml <servers> <server> <id> pkware </id> <username> company_username </username> <password> company_password </password> </server> </servers> Manual If not using a maven-package compatible build system, or if unable to reach the PKWARE repository server via your build tool, you can download the JAR files manually. Navigate to https://packages.smartcrypt.com/#browse/browse:maven-public Sign in using your company\u2019s credentials Refresh the page. You should now be able to see the artifacts. Expand that target artifact all the way and download the JAR files needed Be sure to check the POM files for transitive dependencies and include those in your build as well","title":"Getting the packages"},{"location":"keyManagement/installing/#compatibility","text":"A Java 8 or higher JRE is required. The SDK includes native code, and therefore has system dependencies. PKWARE has confirmed that it works on the following platforms: MacOS Red Hat Enterprise Linux 6+ 64-bit SUSE Linux Enterprise Server 11+ Ubuntu 16.04+ 64-bit Windows 7 / Windows Server 2008 R2 64-bit The SDK is likely to run on other 64-bit GNU-based linux systems with libc version 2.12 or higher.","title":"Compatibility"},{"location":"keyManagement/installing/#package-integrity","text":"The following checksums can be used if wanting to verify the integrity of the package and transitive dependencies published by PKWARE.","title":"Package Integrity"},{"location":"keyManagement/installing/#metaclient-201971jar","text":"SHA1: b6d2e79b1a5329ece7fa8c576e77600e5175c2de MD5: 36e860184faea2f0c18fe39c6d8db8ed","title":"metaclient-2019.7.1.jar"},{"location":"keyManagement/installing/#metaclient-jvm-201971jar","text":"SHA1: 0d5807beb3c473c5d0efeff20e9a80af13b6757d MD5: 584d4d2b9ca62d545c4f7f10f7e617ed","title":"metaclient-jvm-2019.7.1.jar"},{"location":"keyManagement/installing/#key-management-201971jar","text":"SHA1: c0183b0914b749f060e31ed815b4fdb26bc108fa MD5: f88b0c9ebf8947d4ad944faaf841b736","title":"key-management-2019.7.1.jar"},{"location":"keyManagement/keySegregation/","text":"Smartkey segregation \u00b6 The PKWARE Enterprise Manager segregates Smartkeys by the Application they are registered for. This means that an Application will only receive the keys it is expecting and was designed for, not the keys created within the context of another app, which was potentially created by another team. This is best explain by example. Consider two applications: the Smartcrypt Desktop product created by PKWARE, and a custom application written by your development team. Your application will typically fall into one of two buckets - either it wants to use the exact same keys as the Smartcrypt Desktop application is using, or it wants to use keys managed independently of what occurs in the Smartcrypt Desktop application. Share keys with Smartcrypt Desktop and Mobile \u00b6 In the first case, wanting to use the exact same keys as Smartcrypt Desktop, the setup is straightforward. When you tell the SDK which application you are , say you\u2019re Smartcrypt ! Java import com.pkware.smartcrypt.metaclient.NativeMetaClient ; import com.pkware.smartcrypt.protocol.SiteData ; public static NativeMetaClient . Builder configureForSmartcrypt ( NativeMetaClient . Builder builder ) { return builder . appName ( SiteData . APPLICATION_SMARTCRYPT ); } Kotlin import com.pkware.smartcrypt.metaclient.NativeMetaClient import com.pkware.smartcrypt.protocol.SiteData fun NativeMetaClient . Builder . configureForSmartcrypt (): NativeMetaClient . Builder = appName ( SiteData . APPLICATION_SMARTCRYPT ) By indicating that your application is Smartcrypt, the PKWARE Enterprise Manager will give it all the same keys as the Smartcrypt Desktop app. This is especially useful for back office application that only use Community keys, or user-facing applications that want to delegate key creation/modification policies to Smartcrypt Desktop, but want users to be able to perform unique operations with those keys. PKWARE Enterprise Manager configuration \u00b6 There is no additional Manager configuration required when sharing keys with Smartcrypt Desktop. Isolate keys from Smartcrypt Desktop and Mobile \u00b6 When wanting to use keys that should not be shared with Smartcrypt Desktop, the setup is a bit more involved, and requires some planning. Motivation \u00b6 There are good reasons for wanting to segregate your application\u2019s keys from those of Smartcrypt Desktop. For example, consider a scenario where your Archive policy allows users to create new Smartkeys, but in your custom application you want to tightly control which keys get used. In this case, you don\u2019t want the newly created keys from Smartcrypt Desktop spilling into your application. Or vice-versa, perhaps your application creates many keys, and you don\u2019t want those to get listed as options in the Smartcrypt Desktop UI. A theoretical example of this is a chat app, that creates a new Smartkey for each conversation. SDK configuration \u00b6 To configure the SDK, provide the name of your custom application when you tell the SDK which application you are . For example, \"BackOfficeReportExporter\" or \"CorporateChat\" . The important thing is to not call yourself Smartcrypt . PKWARE Enterprise Manager configuration \u00b6 Manager configuration is required when using this setup. Have a PKWARE Enterprise Manager admin follow the PKWARE Enterprise Manager SDK Applications instructions to get going. Be sure to provide the same application name as you are providing the SDK.","title":"Key segregation"},{"location":"keyManagement/keySegregation/#smartkey-segregation","text":"The PKWARE Enterprise Manager segregates Smartkeys by the Application they are registered for. This means that an Application will only receive the keys it is expecting and was designed for, not the keys created within the context of another app, which was potentially created by another team. This is best explain by example. Consider two applications: the Smartcrypt Desktop product created by PKWARE, and a custom application written by your development team. Your application will typically fall into one of two buckets - either it wants to use the exact same keys as the Smartcrypt Desktop application is using, or it wants to use keys managed independently of what occurs in the Smartcrypt Desktop application.","title":"Smartkey segregation"},{"location":"keyManagement/keySegregation/#share-keys-with-smartcrypt-desktop-and-mobile","text":"In the first case, wanting to use the exact same keys as Smartcrypt Desktop, the setup is straightforward. When you tell the SDK which application you are , say you\u2019re Smartcrypt ! Java import com.pkware.smartcrypt.metaclient.NativeMetaClient ; import com.pkware.smartcrypt.protocol.SiteData ; public static NativeMetaClient . Builder configureForSmartcrypt ( NativeMetaClient . Builder builder ) { return builder . appName ( SiteData . APPLICATION_SMARTCRYPT ); } Kotlin import com.pkware.smartcrypt.metaclient.NativeMetaClient import com.pkware.smartcrypt.protocol.SiteData fun NativeMetaClient . Builder . configureForSmartcrypt (): NativeMetaClient . Builder = appName ( SiteData . APPLICATION_SMARTCRYPT ) By indicating that your application is Smartcrypt, the PKWARE Enterprise Manager will give it all the same keys as the Smartcrypt Desktop app. This is especially useful for back office application that only use Community keys, or user-facing applications that want to delegate key creation/modification policies to Smartcrypt Desktop, but want users to be able to perform unique operations with those keys.","title":"Share keys with Smartcrypt Desktop and Mobile"},{"location":"keyManagement/keySegregation/#pkware-enterprise-manager-configuration","text":"There is no additional Manager configuration required when sharing keys with Smartcrypt Desktop.","title":"PKWARE Enterprise Manager configuration"},{"location":"keyManagement/keySegregation/#isolate-keys-from-smartcrypt-desktop-and-mobile","text":"When wanting to use keys that should not be shared with Smartcrypt Desktop, the setup is a bit more involved, and requires some planning.","title":"Isolate keys from Smartcrypt Desktop and Mobile"},{"location":"keyManagement/keySegregation/#motivation","text":"There are good reasons for wanting to segregate your application\u2019s keys from those of Smartcrypt Desktop. For example, consider a scenario where your Archive policy allows users to create new Smartkeys, but in your custom application you want to tightly control which keys get used. In this case, you don\u2019t want the newly created keys from Smartcrypt Desktop spilling into your application. Or vice-versa, perhaps your application creates many keys, and you don\u2019t want those to get listed as options in the Smartcrypt Desktop UI. A theoretical example of this is a chat app, that creates a new Smartkey for each conversation.","title":"Motivation"},{"location":"keyManagement/keySegregation/#sdk-configuration","text":"To configure the SDK, provide the name of your custom application when you tell the SDK which application you are . For example, \"BackOfficeReportExporter\" or \"CorporateChat\" . The important thing is to not call yourself Smartcrypt .","title":"SDK configuration"},{"location":"keyManagement/keySegregation/#pkware-enterprise-manager-configuration_1","text":"Manager configuration is required when using this setup. Have a PKWARE Enterprise Manager admin follow the PKWARE Enterprise Manager SDK Applications instructions to get going. Be sure to provide the same application name as you are providing the SDK.","title":"PKWARE Enterprise Manager configuration"},{"location":"keyManagement/metaClient/","text":"MetaClient \u00b6 MetaClient is a low-level component in the Smartcrypt SDK, responsible for communicating with the PKWARE Enterprise Manager, ensuring integrity of those communications, enforcing policies and enabling use of the SDK offline. MetaClient is very powerful, but comes with a lot of sharp edges. SDK users are encouraged to interact with the SDK through other APIs, like those of the SmartcryptKeyManagement type. Setup \u00b6 The most basic setup is relatively straightforward. Java import com.pkware.smartcrypt.metaclient.MetaClient ; import com.pkware.smartcrypt.metaclient.NativeMetaClient ; import com.pkware.smartcrypt.metaclient.Platform ; import com.pkware.smartcrypt.protocol.SiteData ; import java.util.UUID ; public static MetaClient setUp () { return new NativeMetaClient . Builder () . appName ( SiteData . APPLICATION_SMARTCRYPT ) // TODO Fill in your application version . appVersion ( \"9.99.9999\" ) . deviceName ( UUID . randomUUID (). toString ()) . platform ( Platform . LINUX ) . build (); } Kotlin import com.pkware.smartcrypt.metaclient.MetaClient import com.pkware.smartcrypt.metaclient.NativeMetaClient import com.pkware.smartcrypt.metaclient.Platform import com.pkware.smartcrypt.protocol.SiteData import java.util.UUID fun setUp (): MetaClient = NativeMetaClient . Builder () . appName ( SiteData . APPLICATION_SMARTCRYPT ) // TODO Fill in your application version . appVersion ( \"9.99.9999\" ) . deviceName ( UUID . randomUUID (). toString ()) . platform ( Platform . LINUX ) . build () Lifecycle \u00b6 A single instance of MetaClient should generally be treated as a singleton by your application. You typically want all operations to use that one instance. Using multiple instances will not cause problems, but will results in a lot more network traffic, since the data won\u2019t be cached locally.","title":"MetaClient"},{"location":"keyManagement/metaClient/#metaclient","text":"MetaClient is a low-level component in the Smartcrypt SDK, responsible for communicating with the PKWARE Enterprise Manager, ensuring integrity of those communications, enforcing policies and enabling use of the SDK offline. MetaClient is very powerful, but comes with a lot of sharp edges. SDK users are encouraged to interact with the SDK through other APIs, like those of the SmartcryptKeyManagement type.","title":"MetaClient"},{"location":"keyManagement/metaClient/#setup","text":"The most basic setup is relatively straightforward. Java import com.pkware.smartcrypt.metaclient.MetaClient ; import com.pkware.smartcrypt.metaclient.NativeMetaClient ; import com.pkware.smartcrypt.metaclient.Platform ; import com.pkware.smartcrypt.protocol.SiteData ; import java.util.UUID ; public static MetaClient setUp () { return new NativeMetaClient . Builder () . appName ( SiteData . APPLICATION_SMARTCRYPT ) // TODO Fill in your application version . appVersion ( \"9.99.9999\" ) . deviceName ( UUID . randomUUID (). toString ()) . platform ( Platform . LINUX ) . build (); } Kotlin import com.pkware.smartcrypt.metaclient.MetaClient import com.pkware.smartcrypt.metaclient.NativeMetaClient import com.pkware.smartcrypt.metaclient.Platform import com.pkware.smartcrypt.protocol.SiteData import java.util.UUID fun setUp (): MetaClient = NativeMetaClient . Builder () . appName ( SiteData . APPLICATION_SMARTCRYPT ) // TODO Fill in your application version . appVersion ( \"9.99.9999\" ) . deviceName ( UUID . randomUUID (). toString ()) . platform ( Platform . LINUX ) . build ()","title":"Setup"},{"location":"keyManagement/metaClient/#lifecycle","text":"A single instance of MetaClient should generally be treated as a singleton by your application. You typically want all operations to use that one instance. Using multiple instances will not cause problems, but will results in a lot more network traffic, since the data won\u2019t be cached locally.","title":"Lifecycle"}]}