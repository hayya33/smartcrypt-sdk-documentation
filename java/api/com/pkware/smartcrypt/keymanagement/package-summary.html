<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_212) on Mon Jul 01 22:26:45 CEST 2019 -->
<title>com.pkware.smartcrypt.keymanagement (Smartcrypt SDK 2019.7.1)</title>
<meta name="date" content="2019-07-01">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="com.pkware.smartcrypt.keymanagement (Smartcrypt SDK 2019.7.1)";
        }
    }
    catch(err) {
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li class="navBarCell1Rev">Package</li>
<li>Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev&nbsp;Package</li>
<li><a href="../../../../com/pkware/smartcrypt/keymanagement/smartkeys/package-summary.html">Next&nbsp;Package</a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?com/pkware/smartcrypt/keymanagement/package-summary.html" target="_top">Frames</a></li>
<li><a href="package-summary.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<div class="header">
<p><a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/ParametersAreNonnullByDefault.html?is-external=true" title="class or interface in javax.annotation">@ParametersAreNonnullByDefault</a>
</p>
<h1 title="Package" class="title">Package&nbsp;com.pkware.smartcrypt.keymanagement</h1>
<div class="docSummary">
<div class="block">Smartkey management and basic use; start here!</div>
</div>
<p>See:&nbsp;<a href="#package.description">Description</a></p>
</div>
<div class="contentContainer">
<ul class="blockList">
<li class="blockList">
<table class="typeSummary" border="0" cellpadding="3" cellspacing="0" summary="Interface Summary table, listing interfaces, and an explanation">
<caption><span>Interface Summary</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Interface</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="../../../../com/pkware/smartcrypt/keymanagement/AccountManagement.html" title="interface in com.pkware.smartcrypt.keymanagement">AccountManagement</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../../com/pkware/smartcrypt/keymanagement/DataStorage.html" title="interface in com.pkware.smartcrypt.keymanagement">DataStorage</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../../com/pkware/smartcrypt/keymanagement/PersistenceCallback.html" title="interface in com.pkware.smartcrypt.keymanagement">PersistenceCallback</a></td>
<td class="colLast">
<div class="block">The Smartcrypt SDK persists user information across sessions.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../../com/pkware/smartcrypt/keymanagement/SmartcryptKeyManagement.html" title="interface in com.pkware.smartcrypt.keymanagement">SmartcryptKeyManagement</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../../com/pkware/smartcrypt/keymanagement/Smartkeys.html" title="interface in com.pkware.smartcrypt.keymanagement">Smartkeys</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../../com/pkware/smartcrypt/keymanagement/Users.html" title="interface in com.pkware.smartcrypt.keymanagement">Users</a></td>
<td class="colLast">&nbsp;</td>
</tr>
</tbody>
</table>
</li>
<li class="blockList">
<table class="typeSummary" border="0" cellpadding="3" cellspacing="0" summary="Class Summary table, listing classes, and an explanation">
<caption><span>Class Summary</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Class</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="../../../../com/pkware/smartcrypt/keymanagement/SmartcryptKeyManagementImpl.html" title="class in com.pkware.smartcrypt.keymanagement">SmartcryptKeyManagementImpl</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../../com/pkware/smartcrypt/keymanagement/SmartcryptKeyManagementImpl.Builder.html" title="class in com.pkware.smartcrypt.keymanagement">SmartcryptKeyManagementImpl.Builder</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../../com/pkware/smartcrypt/keymanagement/SmartkeySpec.html" title="class in com.pkware.smartcrypt.keymanagement">SmartkeySpec</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../../com/pkware/smartcrypt/keymanagement/UserSpec.html" title="class in com.pkware.smartcrypt.keymanagement">UserSpec</a></td>
<td class="colLast">&nbsp;</td>
</tr>
</tbody>
</table>
</li>
</ul>
<a name="package.description">
<!--   -->
</a>
<h2 title="Package com.pkware.smartcrypt.keymanagement Description">Package com.pkware.smartcrypt.keymanagement Description</h2>
<div class="block">Smartkey management and basic use; start here!
 <p>
 The Key Management component is the starting point for all interactions with the Smartcrypt SDK. The Key Management
 component makes it easy to login as a Smartcrypt user and to create, retrieve, share, and use Smartkeys. Policies
 configured on the Smartcrypt manager are automatically enforced, and data stored locally are cryptographically tamper
 resistant.

 <h2>Logging In</h2>
 <pre class="brush:java"><code>MetaClient metaClient = new NativeMetaClient.Builder()
         .appName("LoggingIn")
         .appVersion("1.0.0")
         .server("https://oh1.smartcrypt.com/mds")
         .build();
 SmartcryptKeyManagement smartcryptKeyManagement = new SmartcryptKeyManagementImpl.Builder()
         .metaClient(metaClient)
         .persistenceCallback(new InMemoryPersistenceCallback())
         .build();

 AccountManagement accountManagement = smartcryptKeyManagement.getAccountManagement();

 // There are 3 types of login methods: managed, implicit, and unmanaged.
 //
 // Managed login is used for accounts that are managed by Active Directory. The credentials used are the
 // same as those of the domain account.
 //
 // This login variant requires the developer to provide credentials, but does not require any system
 // configuration.
 //
 accountManagement.loginManagedAccount("example@smartcrypt.com", "password");

 // Implicit login uses the domain account of the computer user who owns the process running MetaClient.
 // Typically, this is the user logged-in to Windows, Mac, etc, but may be a different user. On Windows,
 // Integrated Windows Authentication is used for a seamless experience. On *nix systems, Kerberos is used,
 // and the kinit program, or a similar utility, must be used to configure the account prior to login.
 //
 // This login variant does not require the developer to provide any credentials, but does require system
 // configuration by the system administrator.
 //
 // Note that to use implicit login, the developer must supply a server URL to the MetaClient builder.
 accountManagement.loginImplicitAccount();

 /*
 // Unmanaged login is used for accounts that are created in Smartcrypt Enterprise Manager. These do not live
 // in Active Directory. The credentials are owned by Smartcrypt Enterprise Manager.
 //
 // This login variant requires the developer to provide credentials, but does not require any system
 // configuration.
 accountManagement.loginUnManagedAccount("unmanaged@smartcrypt.com", "password");
 </code></pre>

 <h2>Creating and Updating Smartkeys</h2>
 <pre class="brush:java"><code>MetaClient metaClient = new NativeMetaClient.Builder()
         .appName("CreatingAndUpdatingSmartkeys")
         .appVersion("1.0.0")
         .deviceName(UUID.randomUUID().toString())
         .deviceUniqueId(UUID.randomUUID().toString())
         .platform(Platform.LINUX)
         .platformVersion("0")
         .build();
 SmartcryptKeyManagement smartcryptKeyManagement = new SmartcryptKeyManagementImpl.Builder()
         .metaClient(metaClient)
         .persistenceCallback(new InMemoryPersistenceCallback())
         .build();

 smartcryptKeyManagement.getAccountManagement().loginManagedAccount("&lt;your username&gt;", "&lt;your password&gt;");

 Smartkeys smartkeys = smartcryptKeyManagement.getSmartkeys();

 //
 // To create a new Smartkey, prepare a SmartkeySpec with the information for the new key.
 // Keys created using the SDK are always GenericSmartkeys.
 //
 SmartkeySpec createSmartkeySpec = new SmartkeySpec();
 createSmartkeySpec.name = "Sample";
 createSmartkeySpec.addAccess.add("john.doe@example.com");

 // Key creation is synchronous, but you can be notified of updates to the key by listening to the Observable
 Observable&lt;Smartkey&gt; keyObservable = smartkeys.create(createSmartkeySpec);
 Smartkey smartkey = keyObservable
         .doOnEach(genericSmartkeyNotification -&gt; {
             Smartkey key = genericSmartkeyNotification.getValue();
             System.out.println("Got revision " + key.getRevision() + " for created Smartkey " + key.getName());
         })
         .blockingSingle();


 //
 // To update a key, once again prepare a SmartkeySpec. Most types of keys can be updated in some fashion
 //
 SmartkeySpec updateSmartkeySpec = new SmartkeySpec();
 updateSmartkeySpec.name = "Updated Sample";
 updateSmartkeySpec.removeAccess.add("john.doe@example.com");

 // Key updates are synchronous, but once again, you can be notified of updates to the key by listening to
 // the observable
 Observable&lt;Smartkey&gt; updatedKeyObservable = smartkeys.update(smartkey, updateSmartkeySpec);
 updatedKeyObservable
         .subscribe(key -&gt; System.out.println("Got updated Smartkey " + key.getName()));
 </code></pre>

 <h2>Background Processing</h2>
 Smartcrypt Key Management performs operations in the background on your behalf. In some cases, you may need more
 control over how these operations occur. This sample demonstrates monitoring and controlling these operations.

 <pre class="brush:java"><code>MetaClient metaClient = new NativeMetaClient.Builder()
         .appName("BackgroundProcessing")
         .appVersion("1.0.0")
         .deviceName(UUID.randomUUID().toString())
         .deviceUniqueId(UUID.randomUUID().toString())
         .platform(Platform.LINUX)
         .platformVersion("0")
         .build();
 SmartcryptKeyManagement smartcryptKeyManagement = new SmartcryptKeyManagementImpl.Builder()
         .metaClient(metaClient)
         .persistenceCallback(new InMemoryPersistenceCallback())
         .build();

 // Background errors come out as Notifications and can easily be logged or monitored
 smartcryptKeyManagement.getDataStorage().getNotifications()
         .map(unfiltered -&gt; {
             Set&lt;Notification&gt; filtered = new LinkedHashSet&lt;&gt;(unfiltered.size());
             for (Notification notification : unfiltered) {
                 if (notification instanceof SyncProblemNotification) {
                     filtered.add(notification);
                 }
             }
             return filtered;
         })
         .flatMap(Observable::fromIterable)
         .subscribe(problem -&gt; System.out.println(problem.message));

 // Background processing can be paused. This may be necessary if your app goes into the a state where the
 // process is alive, but the user does not expect it to be running, such as a backgrounded mobile app
 smartcryptKeyManagement.pauseBackgroundProcessing();

 // Background processing can also be resumed
 smartcryptKeyManagement.resumeBackgroundProcessing();
 </code></pre>

 <h2>Persisting Smartkeys</h2>
 It is common that encrypted data need to have information about which Smartkey to use stored alongside it. The
 Smartcrypt Key Management SDK provides a mechanism for serializing and deserializing Smartkeys in a way that doesn't
 leak information and makes key retrieval on a separate system bulletproof.

 <pre class="brush:java"><code>MetaClient metaClient = new NativeMetaClient.Builder()
         .appName("PersistingSmartkeys")
         .appVersion("1.0.0")
         .deviceName(UUID.randomUUID().toString())
         .deviceUniqueId(UUID.randomUUID().toString())
         .platform(Platform.LINUX)
         .platformVersion("0")
         .build();
 SmartcryptKeyManagementImpl.Builder builder = new SmartcryptKeyManagementImpl.Builder()
         .metaClient(metaClient);

 // Persistence is done as part of sync. Sync happens on a worker thread, so the persistence happens on the
 // same worker thread. Persistence is synchronous, and the next sync will wait until persistence has
 // completed, but SDK consumers don't need to know that.
 SmartcryptKeyManagement smartcryptKeyManagement = builder
         .persistenceCallback(new InMemoryPersistenceCallback())
         .build();

 smartcryptKeyManagement.getAccountManagement().loginManagedAccount("&lt;your username&gt;", "&lt;your password&gt;");

 Smartkeys smartkeys = smartcryptKeyManagement.getSmartkeys();

 // For this example, any Smartkey will do. We'll just take the first one we get
 Smartkey smartkey = smartkeys.listAll()
         .blockingFirst()
         .iterator().next();

 // Smartkey serialization is straightforward. When serializing, the information of the provided Smartkey is
 // used.
 String serializedRepresentation = smartkeys.serialize(smartkey);
 System.out.println("Serialized Smartkey " + smartkey.getName() + ": " + serializedRepresentation);

 // Retrieving a Smartkey from its serialized form is also straightforward.
 Smartkey deserializedSmartkey = smartkeys.deserialize(serializedRepresentation).blockingFirst();
 System.out.println("Smartkey " + deserializedSmartkey.getName());
 </code></pre>

 <h2>Persisting Metadata</h2>

 <pre class="brush:java"><code>MetaClient metaClient = new NativeMetaClient.Builder()
         .appName("PersistingMetadata")
         .appVersion("1.0.0")
         .deviceName(UUID.randomUUID().toString())
         .deviceUniqueId(UUID.randomUUID().toString())
         .platform(Platform.LINUX)
         .platformVersion("0")
         .build();
 SmartcryptKeyManagementImpl.Builder builder = new SmartcryptKeyManagementImpl.Builder()
         .metaClient(metaClient);

 // Persistence is done as part of sync. Sync happens on a worker thread, so the persistence happens on the
 // same worker thread. Persistence is synchronous, and the next sync will wait until persistence has
 // completed, but SDK consumers don't need to know that.
 SmartcryptKeyManagement smartcryptKeyManagement = builder
         .persistenceCallback(new FilePersistenceCallback())
         .build();

 // Data restore, both threading and timing, is controlled by the developer
 DataStorage dataStorage = smartcryptKeyManagement.getDataStorage();
 dataStorage.restore();

 // Be sure to define this class somewhere
 class FilePersistenceCallback implements PersistenceCallback {
     private final static String folder = "serializedMetadata";

     public boolean onSaveData(Map&lt;String, String&gt; toSave, Set&lt;String&gt; toDelete) {
         try {
             Files.createDirectory(Paths.get(folder));
             for (Map.Entry&lt;String, String&gt; datum : toSave.entrySet()) {
                 try (BufferedWriter writer = Files.newBufferedWriter(Paths.get(folder, datum.getKey()))) {
                     writer.write(datum.getValue());
                 }
             }

             for (String name : toDelete) {
                 Files.deleteIfExists(Paths.get(folder, name));
             }
             return true;
         } catch (IOException e) {
             return false;
         }
     }

     public Map&lt;String, String&gt; onLoadData() {
         try {
             return Files.list(Paths.get(folder))
                     .collect(Collectors.toMap(
                             path -&gt; path.getFileName().toString(),                      // Key
                             fileName -&gt; {                                               // Value
                                 try {
                                     return new String(Files.readAllBytes(fileName));
                                 } catch (IOException e) {
                                     e.printStackTrace();
                                     return "";
                                 }
                             }
                     ));
         } catch (IOException e) {
             return Collections.emptyMap();
         }
     }
 }
 </code></pre>

 <h2>Working with Observables</h2>
 The Smartcrypt Key Management SDK relies heavily on Observables. These may be unfamiliar, but are easy to get a hang
 of or convert to a more familiar paradigm. If unfamiliar with reactive programming, we recommend taking a look at the
 [ReactiveX website](http://reactivex.io/tutorials.html) for tutorials, guides, and more.

 <pre class="brush:java"><code>// Observables emit a stream of events. This is a push model rather than a pull model.
 Observable&lt;Integer&gt; observable = Observable.range(0, 5);

 // Observables can be transformed
 Observable&lt;String&gt; intsAsStrings = observable.map(Object::toString);

 // Use common stream/observable operators
 Observable&lt;String&gt; filteredInts = intsAsStrings.filter(number -&gt; !"3".equals(number));

 // Observables only process when subscribed to. All of the previous "work" is only setup - none of it has
 // run yet. When we subscribe now, the work will happen.
 Disposable subscription = filteredInts.subscribe(System.out::println);

 // Subscriptions must be disposed when we're done with them, otherwise the stream will continue processing
 // when we no longer need it
 subscription.dispose();

 //
 // Observables can also be made blocking, effectively making them a single, synchronous call
 //
 Integer lastNumberBlocking = Observable.range(0, 4).blockingLast();
 System.out.println("With a blocking call: " + lastNumberBlocking);
 </code></pre></div>
</div>
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li class="navBarCell1Rev">Package</li>
<li>Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
<div class="aboutLanguage">Copyright 2012-2019, PKWARE, Inc.</div>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev&nbsp;Package</li>
<li><a href="../../../../com/pkware/smartcrypt/keymanagement/smartkeys/package-summary.html">Next&nbsp;Package</a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?com/pkware/smartcrypt/keymanagement/package-summary.html" target="_top">Frames</a></li>
<li><a href="package-summary.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
